<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>8 メタ回帰 | Doing Meta-Analysis in R</title>
<meta name="author" content="Mathias Harrer">
<meta name="author" content="Pim Cuijpers">
<meta name="author" content="Toshi A. Furukawa">
<meta name="author" content="David D. Ebert">
<meta name="description" content="前 章では、メタ分析の「ツール」に新しい手法としてサブグループ分析を追加した。前章で学んだのは、サブグループ解析では、1つの全体的な効果を見つけることから解析の焦点をずらすという点である。その代わりとして、データ中の異質性のパターンとその原因を調査することができるのである。...">
<meta name="generator" content="bookdown 0.36 with bs4_book()">
<meta property="og:title" content="8 メタ回帰 | Doing Meta-Analysis in R">
<meta property="og:type" content="book">
<meta property="og:description" content="前 章では、メタ分析の「ツール」に新しい手法としてサブグループ分析を追加した。前章で学んだのは、サブグループ解析では、1つの全体的な効果を見つけることから解析の焦点をずらすという点である。その代わりとして、データ中の異質性のパターンとその原因を調査することができるのである。...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="8 メタ回帰 | Doing Meta-Analysis in R">
<meta name="twitter:site" content="@MathiasHarrer">
<meta name="twitter:description" content="前 章では、メタ分析の「ツール」に新しい手法としてサブグループ分析を追加した。前章で学んだのは、サブグループ解析では、1つの全体的な効果を見つけることから解析の焦点をずらすという点である。その代わりとして、データ中の異質性のパターンとその原因を調査することができるのである。...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Fira_Sans-0.4.7/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.7/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.5.1/transition.js"></script><script src="libs/bs3compat-0.5.1/tabs.js"></script><script src="libs/bs3compat-0.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
<style>

    :root {
      --background-color: #FFFEFA;
      --text-color: #000;
      --highlight-color: #277DB0;
      --border-color: #999896;
      --grey-color: #6C6C6C;
      --line-color: #eee;
      --bg-box: #f5f5f5;
      --box-border-color: #eeeeee;
      --code-bg: #f8f8f8;
      --code-chunk-bg: linear-gradient(160deg,#f8f8f8 0, #f1f1f1 100%);
      --code-text-color: #212529;
      --hr-border-top: 1px solid rgba(0,0,0,0.1);
      --table-text-color: #000;
      --toc-active: #eee;
      --form-color: #4D4C4B;
      --form-background-color: #FFFEFA;
      --form-border: 1px solid #999896;
      --aa-cursor-background-color: #B2D7FF;
    }


    [data-theme="dark"] {
      --background-color: #2b2b2b;
      --text-color: #ffffff;
      --highlight-color: #34a8ed;
      --border-color: yellow;
      --grey-color: #cfcfcf;
      --line-color: #575757;
      --bg-box: #474747;
      --box-border-color: #474747;
      --code-bg: #474747;
      --code-chunk-bg: linear-gradient(160deg,#CDCDCD 0,#f1f1f1 100%);
      --code-text-color: #ffffff;
      --hr-border-top: 1px solid #575757;
      --table-text-color: #ffffff;
      --toc-active: #474747;
      --form-color: #cfcfcf;
      --form-background-color: #474747;
      --form-border: 1px solid #575757;
      --aa-cursor-background-color: #2b2b2b;
    }

    .algolia-autocomplete .aa-dropdown-menu .aa-suggestion {
      color: var(--form-color);
      border-bottom: 1px var(--form-border) solid;
      background-color: var(--form-background-color);
    }

    .algolia-autocomplete .aa-dropdown-menu .aa-suggestion.aa-cursor {
      background-color: var(--aa-cursor-background-color);
    }

    strong {
      font-family: "Helvetica Neue",
        Arial,
        "Hiragino Kaku Gothic ProN",
        "Hiragino Sans",
        Meiryo,
        sans-serif;
      font-weight: bolder;
    }

    .form-control {
      color: var(--form-color);
      background-color: var(--form-background-color);
      border: var(--form-border);
    }

    .form-control:focus {
      color: var(--text-color);
      background-color: var(--form-background-color);
      border: var(--form-border);
    }


    nav[data-toggle="toc"] .nav a.nav-link.active, nav[data-toggle="toc"] .nav .nav-link.active > li > a {
        background-color: var(--toc-active);
    }

    .btn-circle.btn-md {
      width: 50px;
      height: 50px;
      padding: 7px 10px;
      border-radius: 25px;
      font-size: 10px;
      text-align: center;
    }


    .lightable-classic td {
      color: var(--text-color);
    }


    .table {
      color: var(--table-text-color);
    }

    hr {
      border-top: var(--hr-border-top);
    }

    code {
      background-color: var(--code-bg);
      color: var(--code-text-color);
    }

    pre {
      background-image: var(--code-chunk-bg);
    }

    body {
      background-color: var(--background-color);
      color: var(--text-color);
    }

    a {
      color: var(--highlight-color);
    }

    .header-section-number {
      color: var(--grey-color);
    }

    small.text-muted {
      color: var(--grey-color) !important;
    }


    .firstcharacter {
      color: var(--highlight-color);
    }

    p.caption {
      color: var(--grey-color);
    }

    .figure {
      border-top: 2px solid var(--line-color);
      border-bottom: 2px solid var(--line-color);
    }


    .inline-figure {
      border: 0;
      box-shadow: none;
    }

    .boxinfo {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxinfo:before {
        content: '\f0eb';
        font-family: FontAwesome;
        left:20px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxempty {
      padding: 1em 1em 1em 1.1em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxempty:before {
        content: '\f0eb';
        font-family: FontAwesome;
        left:0px;
        position:absolute;
        font-size: 30px;
        color: transparent;
     }

    .boximportant {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boximportant:before {
        content: '\f06a';
        font-family: FontAwesome;
        left:13px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxreport {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxreport:before {
        content: '\f570';
        font-family: FontAwesome;
        left:15px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxdmetar {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .csl-entry {
      margin-bottom: 20px;
      padding-left: 1.5em;
      text-indent:-1.5em;
    }

    .boxdmetar:before {
        content: '\f4f7';
        font-family: FontAwesome;
        left:10px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxquestion {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxquestion:before {
        content: '\f059';
        font-family: FontAwesome;
        left:12px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .mode-switch {
      font-size: 0.9rem;
    }

    img {
      max-width: 100%;
      height: auto;
      border-radius: .25rem;
    }


    .firstcharacter {
      color: var(--highlight-color);
      float: left;
      font-size: 40px;
      line-height: 50px;
      padding-bottom: 2px;
      padding-right: 8px;
      padding-left: 2px;
    }


    .btn-circle.btn-sm {
        width: 30px;
        height: 30px;
        padding: 6px 0px;
        border-radius: 15px;
        font-size: 20px;
        text-align: center;
    }
    .btn-circle.btn-md {
        width: 50px;
        height: 50px;
        padding: 7px 10px;
        border-radius: 25px;
        font-size: 20px;
        text-align: center;
    }
    .btn-circle.btn-xl {
        width: 60px;
        height: 60px;
        padding: 7px 7px;
        border-radius: 35px;
        font-size: 30px;
        text-align: center;
    }

    #critical-btn.btn-secondary {
      background-color: var(--grey-color);
      border-color: var(--grey-color);
    }

    .sticky-item {
        position: fixed;
        bottom: 30px;
        right: 30px;
    }



    </style>
<link rel="shortcut icon" href="favicon.ico">
<script type="text/x-mathjax-config">
    const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
    for (let popover of popovers){
      const div = document.createElement('div');
      div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
      div.innerHTML = popover.getAttribute('data-content');

      // Will this work with TeX on its own line?
      var has_math = div.querySelector("span.math");
      if (has_math) {
        document.body.appendChild(div);
      	MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
      	MathJax.Hub.Queue(function(){
          popover.setAttribute('data-content', div.innerHTML);
      	})
      }
    }
    </script><link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script><script type="text/javascript">
      // Add switch element
      document.addEventListener('DOMContentLoaded', function(event){
        let darkSwitch = document.createElement('div');
        darkSwitch.innerHTML = "<div class='sticky-item'><button type='button' id='critical-btn' class='btn btn-dark btn-circle btn-xl'>🌓</button></div>"
        document.body.appendChild(darkSwitch);
      })

    $(document).ready(function() {

        $("#critical-btn").click(function () {

            if ($(this).hasClass('btn-dark')){
                $('#critical-btn').removeClass('btn-dark').addClass('btn-secondary');
                $(this).addClass('btn-secondary').removeClass('btn-dark');
            }

            else if ($(this).hasClass('btn-secondary')){
                $('#critical-btn').removeClass('btn-secondary').addClass('btn-dark');
                $(this).addClass('btn-dark').removeClass('btn-secondary');
            }

        })
    })
    </script><script type="text/javascript">
      // Wait for document to load
      document.addEventListener("DOMContentLoaded", function(event) {
        document.documentElement.setAttribute("data-theme", "light");

        // Get our button switcher
        var themeSwitcher = document.getElementById("critical-btn");

        // When our button gets clicked
        themeSwitcher.onclick = function() {
          // Get the current selected theme, on the first run
          // it should be `light`
          var currentTheme = document.documentElement.getAttribute("data-theme");

          // Switch between `dark` and `light`
          var switchToTheme = currentTheme === "dark" ? "light" : "dark"

          // Set our currenet theme to the new one
          document.documentElement.setAttribute("data-theme", switchToTheme);

          // Save current selection
          localStorage.setItem('themeMode', switchToTheme);

        }
      });

      // keep selection across pages
      document.addEventListener('DOMContentLoaded', function(event){
        const currentTheme = localStorage.getItem('themeMode')
        if (currentTheme === 'dark'){
        document.documentElement.setAttribute("data-theme", 'dark');
          if ($("#critical-btn").hasClass('btn-dark')) {
            $('#critical-btn').removeClass('btn-dark').addClass('btn-secondary');
            $('#critical-btn').addClass('btn-secondary').removeClass('btn-dark');
          }
        } else {
        document.documentElement.setAttribute("data-theme", 'light');
          if ($("#critical-btn").hasClass('btn-secondary')) {
            $('#critical-btn').removeClass('btn-secondary').addClass('btn-dark');
            $('#critical-btn').addClass('btn-dark').removeClass('btn-secondary');
          }
      }})
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="A Hands-on Guide">Doing Meta-Analysis in R</a>:
        <small class="text-muted">A Hands-on Guide</small>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">ようこそ！</a></li>
<li><a class="" href="preface.html">序章</a></li>
<li><a class="" href="about-the-authors.html">著者について</a></li>
<li class="book-part">はじめに</li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> はじめに</a></li>
<li><a class="" href="discovering-R.html"><span class="header-section-number">2</span> R の発見</a></li>
<li class="book-part">Rでメタ分析</li>
<li><a class="" href="effects.html"><span class="header-section-number">3</span> 効果量</a></li>
<li><a class="" href="pooling-es.html"><span class="header-section-number">4</span> 効果量のプール</a></li>
<li><a class="" href="heterogeneity.html"><span class="header-section-number">5</span> 研究間異質性</a></li>
<li><a class="" href="forest.html"><span class="header-section-number">6</span> フォレストプロット</a></li>
<li><a class="" href="subgroup.html"><span class="header-section-number">7</span> サブグループ解析</a></li>
<li><a class="active" href="metareg.html"><span class="header-section-number">8</span> メタ回帰</a></li>
<li><a class="" href="pub-bias.html"><span class="header-section-number">9</span> 出版バイアス</a></li>
<li class="book-part">高度な分析</li>
<li><a class="" href="multilevel-ma.html"><span class="header-section-number">10</span> 「マルチレベル」メタ分析</a></li>
<li><a class="" href="sem.html"><span class="header-section-number">11</span> 構造方程式モデリングメタ分析</a></li>
<li><a class="" href="netwma.html"><span class="header-section-number">12</span> ネットワークメタ分析</a></li>
<li><a class="" href="bayesian-ma.html"><span class="header-section-number">13</span> ベイズメタ分析</a></li>
<li class="book-part">各種ツール</li>
<li><a class="" href="power.html"><span class="header-section-number">14</span> 検出力分析</a></li>
<li><a class="" href="risk-of-bias-plots.html"><span class="header-section-number">15</span> バイアスリスクのプロット</a></li>
<li><a class="" href="reporting-reproducibility.html"><span class="header-section-number">16</span> 報告と再現性</a></li>
<li><a class="" href="es-calc.html"><span class="header-section-number">17</span> 効果量の計算と換算</a></li>
<li class="book-part">付録</li>
<li><a class="" href="qanda.html"><span class="header-section-number">A</span> Q&amp;A</a></li>
<li><a class="" href="formula.html"><span class="header-section-number">B</span> 効果量の計算式</a></li>
<li><a class="" href="symbollist.html"><span class="header-section-number">C</span> シンボルマーク一覧</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">D</span> R およびパッケージ情報</a></li>
<li><a class="" href="corrections.html"><span class="header-section-number">E</span> 訂正・備考</a></li>
<li><a class="" href="%E6%9C%AC%E6%9B%B8%E3%81%AE%E5%BC%95%E7%94%A8.html">本書の引用</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="metareg" class="section level1" number="8">
<h1>
<span class="header-section-number">8</span> メタ回帰<a class="anchor" aria-label="anchor" href="#metareg"><i class="fas fa-link"></i></a>
</h1>
<hr>
<div class="inline-figure"><img src="_figs/airplanes.jpg"></div>
<p><br></p>
<p></p>
<p><span class="firstcharacter">前</span>
章では、メタ分析の「ツール」に新しい手法としてサブグループ分析を追加した。前章で学んだのは、サブグループ解析では、1つの全体的な効果を見つけることから解析の焦点をずらすという点である。その代わりとして、データ中の異質性のパターンとその原因を調査することができるのである。</p>
<p></p>
<p>また、サブグループ解析は<strong>メタ分析</strong>の特殊な形態であることを述べた。「回帰」という言葉を聞いたことがあるかと思われる。回帰分析は、最も一般的な統計手法の1つで、さまざまな分野で使用されている。最も単純な形では、回帰モデルは、ある変数 <span class="math inline">\(x\)</span> の値を使って、別の変数 <span class="math inline">\(y\)</span> の値を予測しようとするものである。通常、回帰モデルは、<span class="math inline">\(x\)</span> と <span class="math inline">\(y\)</span> の両方の値が測定された個人またはサンプルからなるデータに基づいている。</p>
<p></p>
<p>メタ回帰では、このロジックは<strong>全ての研究</strong>に適用される。変数 <span class="math inline">\(x\)</span> は、研究の特徴、たとえば、実施された年などを表す。この情報に基づいて、メタ回帰モデルは、研究の効果量である <span class="math inline">\(y\)</span> を予測しようとする。しかし、予測される変数として効果量が使用されると、より複雑になる。</p>
<p>Chapter <a href="effects.html#what-is-es">3.1</a> ですでに、観察された効果量 <span class="math inline">\(\hat\theta\)</span> は、その標準誤差によって、研究の真の効果のおおよそ<strong>正確な</strong>推定量になりうることを学んだ。「通常の」メタ分析では、研究に大小の重みを与えることによって、これを考慮に入れている。メタ回帰では、ある研究のサンプル誤差が他より低いとき、その推定値はより「真実」に近いと仮定できるため、モデルはこれらの研究に注意を払う必要がある。</p>
<p></p>
<p>メタ回帰は、<strong>混合効果モデル</strong>を仮定することによって、これを実現する。このモデルは、観察された研究がサンプルエラーや研究間の異質性によって、真の全体効果から逸脱するという事実を説明する。しかし、より重要なのは、1 つまたは複数の変数 <span class="math inline">\(x\)</span>を用いて、真の効果量の差を予測するために使用することである。サブグループ分析も混合効果モデルに基づいていることは、すでに前章で述べたとおりである。この章では、もう少し掘り下げて、なぜサブグループ分析とメタ回帰が本質的に関連しているのかを議論する。</p>
<p>メタ回帰は、それなりの限界はあるものの、メタ分析において非常に強力なツールとなり得る。また、非常に汎用性が高い。たとえば、<strong>多重メタ回帰</strong>は、1つだけでなく、複数の予測変数とそれらの交互作用 (interaction) を含めることができる。本章の後半では、多重メタ回帰と、 <em>R</em> を用いたメタ回帰の実施方法について説明する。</p>
<p><br></p>
<div id="the-metareg-model" class="section level2" number="8.1">
<h2>
<span class="header-section-number">8.1</span> メタ回帰モデル<a class="anchor" aria-label="anchor" href="#the-metareg-model"><i class="fas fa-link"></i></a>
</h2>
<hr>
<p>過去に、参加者を分析単位とする一次研究のデータを使って、すでに回帰を行ったことがあるだろう。メタ分析では、通常、各参加者の個別のデータは得られず、集約された結果に頼るしかない。これが、<strong>研究レベル</strong>の予測因子でメタ回帰を実行しなければならない理由である。</p>
<p>また、一次試験よりもはるかに大きなサンプルで分析を行っても、メタ回帰が有用となるだけのデータポイントが得られない可能性があることを意味する。 Chapter <a href="subgroup.html#limits-subgroup">7.2</a> で、<span class="math inline">\(K&lt;\)</span> 10 件の時、サブグループ解析が意味をなさないことが多いことを取り上げた。Borenstein ら <span class="citation">(<a href="references.html#ref-borenstein2011introduction">2011, chap. 20</a>)</span> は、このガイドラインはメタ回帰モデルにも適用できるかもしれないが、鉄則と見なすべきではないと言及している。</p>
<p>従来の回帰では、人物 <span class="math inline">\(i\)</span> の値 <span class="math inline">\(y_i\)</span> を、<strong>予測因子</strong> (または<strong>共変量</strong>) <span class="math inline">\(x_i\)</span> と回帰係数 <span class="math inline">\(\beta\)</span> を使って推定したい。したがって、標準的な回帰式は次のようになる。</p>
<p><span class="math display" id="eq:mr1">\[\begin{equation}
\hat{y_i} = \beta_0 + \beta_1x_i
\tag{8.1}
\end{equation}\]</span></p>
<p>メタ回帰では、予測したい変数 <span class="math inline">\(y\)</span> は、研究 <span class="math inline">\(k\)</span> の観察された効果量 <span class="math inline">\(\hat\theta_k\)</span> (シータハットと読む) である。<strong>メタ回帰</strong>の式は、正規回帰モデルの式に似ている。</p>
<p><span class="math display" id="eq:mr2">\[\begin{equation}
\hat\theta_k = \theta + \beta x_{k} + \epsilon_k+\zeta_k
\tag{8.2}
\end{equation}\]</span></p>
<p>この式は、2つの追加項、<span class="math inline">\(\epsilon_k\)</span> (イプシロン k と読む) と <span class="math inline">\(\zeta_k\)</span> (ゼータ k と読む) を含んでいることに注意されたい。同じ項がランダム効果モデルの式 (Chapter <a href="pooling-es.html#rem">4.1.2</a> ) にもあり、2 種類の独立した誤差を意味する。1 つ目の <span class="math inline">\(\epsilon_k\)</span> は、研究の効果量が真の効果から逸脱するサンプル誤差である。</p>
<p>2 つ目の誤差、<span class="math inline">\(\zeta_k\)</span> は、研究の真の効果量でさえ、効果量の包括的な分布からサンプルされているに過ぎないことを表している。これは、私たちのデータには研究間の異質性が存在することを意味し、これは異質性分散 <span class="math inline">\(\tau^2\)</span> によって捕捉される。</p>
<p>
</p>
<p>上記の式は、<strong>固定</strong>効果 (<span class="math inline">\(\beta\)</span> 係数) と<strong>ランダム</strong>効果 (<span class="math inline">\(\zeta_k\)</span>) を含むので、メタ回帰で使用されるモデルは、<strong>混合効果モデル</strong>と呼ばれることも多い。概念的には、このモデルは Chapter <a href="subgroup.html#comparing-the-subgroup-effects">7.1.2</a> で説明した混合効果モデルと同じで、サブグループ解析がどのように機能するかを説明したものである。</p>
<p><br></p>
<div id="カテゴリカル予測変数のメタ回帰" class="section level3" number="8.1.1">
<h3>
<span class="header-section-number">8.1.1</span> カテゴリカル予測変数のメタ回帰<a class="anchor" aria-label="anchor" href="#%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA%E3%82%AB%E3%83%AB%E4%BA%88%E6%B8%AC%E5%A4%89%E6%95%B0%E3%81%AE%E3%83%A1%E3%82%BF%E5%9B%9E%E5%B8%B0"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p></p>
<p>実際、前述のように、サブグループ分析は、カテゴリカル予測変数のメタ回帰にほかならない。そのようなカテゴリカル変数は、たとえば、<strong>ダミー・コーディング</strong> によって含めることができる。</p>
<p><span class="math display" id="eq:mr3">\[\begin{equation}
  D_g=\begin{cases}
    0: &amp; \text{Subgroup A}\\
    1: &amp; \text{Subgroup B.}
  \end{cases}
  \tag{8.3}
\end{equation}\]</span></p>
<p>サブグループ分析をメタ回帰の形で指定するには、共変量 <span class="math inline">\(x_k\)</span> を <span class="math inline">\(D_g\)</span> に置き換えるだけでよい。</p>
<p><span class="math display" id="eq:mr4">\[\begin{equation}
\hat\theta_k = \theta + \beta D_g +\epsilon_k+\zeta_k.
\tag{8.4}
\end{equation}\]</span></p>
<p>この式を理解するためには、左から右へ読む必要がある。メタ回帰モデルの目的は、他の統計モデルと同様、観測されたデータがどのように生成されたかを説明することである。私たちの場合、これはメタ分析におけるいくつかの研究 (<span class="math inline">\(k\)</span>) の観察された効果量 <span class="math inline">\(\hat\theta_k\)</span> である。上の式はレシピのように機能し、観察された効果を生み出すためにどの材料が必要かを教えてくれる。</p>
<p>まず、<span class="math inline">\(\theta\)</span> は回帰モデルにおける<strong>切片</strong>として機能する。<span class="math inline">\(\theta\)</span> の値は、サブグループAの真の全体効果量と同じである。この理由を見るために、次の「成分」である項 <span class="math inline">\(\beta D_g\)</span> を見る必要がある。この項の <span class="math inline">\(\beta\)</span> の値は、サブグループ A とサブグループ B の間の効果量の差 <span class="math inline">\(\theta_{\Delta}\)</span> を表している。<span class="math inline">\(\beta\)</span> の値に、研究がサブグループ A (<span class="math inline">\(D_g = 0\)</span>) またはサブグループ B (<span class="math inline">\(D_g = 1\)</span>) のどちらに属しているかによって 0 または 1 のどちらかになる <span class="math inline">\(D_g\)</span> を掛けている。</p>
<p>ゼロを掛けるとゼロになるので、サブグループAの研究を扱っているときは、<span class="math inline">\(\beta D_g\)</span> の項は方程式から完全に外れる。一方、<span class="math inline">\(D_g=1\)</span> のとき、1を掛けるので <span class="math inline">\(\beta\)</span> が方程式に残り、<span class="math inline">\(\theta\)</span> に足され、サブグループ B の全体的な効果量が得られる。基本的に、ダミー予測変数は<strong>二つ</strong>の式を<strong>ひとつ</strong>に統合する方法である。これは、各サブグループの式を個別に書き出すと、簡単にわかる。</p>
<p><span class="math display" id="eq:mr5">\[\begin{equation}
  D_g=\begin{cases}
    0: &amp; \text{$\hat\theta_k = \theta_A + \epsilon_k+\zeta_k$}\\
    1: &amp; \text{$\hat\theta_k = \theta_A + \theta_{\Delta} +\epsilon_k+\zeta_k$}
  \end{cases}
  \tag{8.5}
\end{equation}\]</span></p>
<p>このように書くと、この式は、実際には、サブグループ A とサブグループ B の2つのモデルを含んでいることが明らかになる。モデル間の主な違いは、<span class="math inline">\(\beta\)</span> (上の式では <span class="math inline">\(\theta_{\Delta}\)</span> と表記) の値によって、第2サブグループの効果が上下に「シフト」されることである。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:subgroups2"></span>
<img src="images/subgroups2_sep.png" alt="カテゴリ予測因子を用いたメタ回帰 (サブグループ)。" width="70%"><p class="caption">
Figure 8.1: カテゴリ予測因子を用いたメタ回帰 (サブグループ)。
</p>
</div>
<p>これは、サブグループ分析が通常の回帰と同じように動作することを明確にするもので、ある変数 <span class="math inline">\(x\)</span> を使って <span class="math inline">\(y\)</span> の値を予測する。特別なのは、<span class="math inline">\(\beta x_k\)</span> が連続的ではなく、ある研究が特定のサブグループに属するかどうかに応じて、予測に追加する固定値であるということである。この固定値 <span class="math inline">\(\beta\)</span> は、2つのサブグループ間の効果量の差の推定値である。</p>
<p><br></p>
</div>
<div id="metareg-continuous" class="section level3" number="8.1.2">
<h3>
<span class="header-section-number">8.1.2</span> 連続予測因子によるメタ回帰<a class="anchor" aria-label="anchor" href="#metareg-continuous"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p></p>
<p>しかし、「メタ回帰」というと、普通は<strong>連続</strong>変数を予測変数としたモデルを思い浮かべる。そこで、8.2式に示す一般的なメタ回帰の式に戻る。ここでも、前に説明した回帰の用語が使われているが、少し違う目的を持っている。<span class="math inline">\(\theta\)</span> 項は再び切片を表すが、今度は <span class="math inline">\(x = 0\)</span> のときに予測される効果量を表す。</p>
<p>切片に、<span class="math inline">\(\beta x_k\)</span> 項が加えられる。この部分は、<strong>回帰傾き</strong>を生成する。つまり、連続変数 <span class="math inline">\(x\)</span> と<strong>回帰重み</strong> <span class="math inline">\(\beta\)</span> が掛け算され、共変量値の予測効果を低くしたり高くしたりする。</p>
<p>メタ回帰モデルの目的は、研究の<strong>予測</strong>効果量と<strong>真の</strong>効果量の差を最小化する <span class="math inline">\(\theta\)</span> と <span class="math inline">\(\beta\)</span> の値を見つけることである ( Figure <a href="metareg.html#fig:subgroups3">8.2</a> を参照)。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:subgroups3"></span>
<img src="images/subgroups3_sep.png" alt="連続変数予測因子と４つの研究のメタ回帰" width="70%"><p class="caption">
Figure 8.2: 連続変数予測因子と４つの研究のメタ回帰
</p>
</div>
<p>メタ回帰式をよく見てみると、2種類の項が含まれていることがわかる。いくつかの項には添え字 (<span class="math inline">\(k\)</span>) があり、他の項には添え字がない。添え字 (<span class="math inline">\(k\)</span>) は、ある値が研究ごとに<strong>異なる</strong>ことを示す。ある項が添え字 (<span class="math inline">\(k\)</span>) を含んでいない場合、それはすべての研究で同じである。</p>
<div class="inline-figure"><img src="images/metareg_form_sep.png" width="45%" style="display: block; margin: auto;"></div>
<p>メタ回帰では、<span class="math inline">\(\theta\)</span> と <span class="math inline">\(\beta\)</span> の両方が不変、または固定である。予測変数の変動と観察された効果に基づいて、<strong>回帰線</strong>の形で、データの根底にある<strong>固定パターン</strong>を「抽出」しようとするのである。メタ回帰モデルがデータによく当てはまる場合、推定されたパラメータ <span class="math inline">\(\theta\)</span> と <span class="math inline">\(\beta\)</span> は、モデルが<strong>今まで見たことのない</strong>研究の効果量を予測するのに使うことができる (<span class="math inline">\(x\)</span> がわかっていればの話であるが)。</p>
<p><span class="math inline">\(\epsilon_k\)</span> と研究間異質性 <span class="math inline">\(\zeta_k\)</span> の両方を考慮すると、メタ回帰は、観察された効果量だけでなく、関心のあるすべての研究の「宇宙」に対して、うまく<strong>一般化する</strong>モデルを見つけようとするものである。</p>
<p><br></p>
</div>
<div id="metareg-model-fit" class="section level3" number="8.1.3">
<h3>
<span class="header-section-number">8.1.3</span> モデルの適合性を評価<a class="anchor" aria-label="anchor" href="#metareg-model-fit"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>メタ回帰モデルの重要な点は、効果量のプールに使用する「通常の」ランダム効果モデルの拡張とみなすことができる点である。ランダム効果モデルは、傾き項を含まないメタ回帰モデルに過ぎない。傾きがないので、ランダム効果モデルは、各研究について単純に<strong>同じ値</strong>を予測する。つまり、プールされた効果量の推定値 <span class="math inline">\(\mu\)</span> であり、これは切片と同じである。</p>
<p>
</p>
<p>最初のステップでは、メタ回帰の計算は、したがってランダム効果メタ分析のものとよく似ており、研究間異質性 <span class="math inline">\(\tau^2\)</span> が Chapter <a href="pooling-es.html#tau-estimators">4.1.2.1</a> で説明した方法 (例えば、DerSimonian-Laird 法または REML 法) のいずれかを使って推定される。次のステップでは、固定重み <span class="math inline">\(\theta\)</span> と <span class="math inline">\(\beta\)</span> が推定される。通常の線形回帰モデルは、<strong>通常の最小2乗</strong> (ordinary least squares, OLS) 法を用いて、データに最もよく適合する回帰直線を見つける。メタ回帰では、<strong>重み付き最小2乗</strong> (weighted least squares, WLS)と呼ばれる修正された方法が使用され、より小さな標準誤差を持つ研究がより高い重みを与えられるようにする。</p>
<p>最適解が見つかったら、新しく追加された回帰項が効果量の異質性の一部を説明しているかどうかを確認することができる。メタ回帰モデルがデータによく適合している場合、真の効果量は、プール効果量 <span class="math inline">\(\hat\mu\)</span> と比較して回帰直線からの偏差が小さくなる。この場合、予測因子 <span class="math inline">\(x\)</span> は、メタ分析における異質性分散の一部を<strong>説明</strong>する。</p>
<div class="inline-figure"><img src="images/rem_mem_sep.png" width="100%" style="display: block; margin: auto;"></div>
<p>したがって、メタ回帰モデルの適合性は、それが異質性分散のどれだけを説明するかをチェックすることによって評価することができる。混合効果モデルに含まれる予測変数は、<strong>残差</strong> (residual)、または説明されない異質性分散の量を最小化する必要があり、これは、<span class="math inline">\(\tau^2_{\text{unexplained}}\)</span> で示される。</p>
<p>回帰分析では、モデルによって説明される変動の割合を定量化するために、<span class="math inline">\(R^2\)</span> 指数が一般的に使用される。類似の指数である <span class="math inline">\(R^2_{*}\)</span> もメタ回帰で計算することができる。ここでは、観測されたデータ点ではなく、<strong>真の効果量</strong> を扱うので、メタ回帰の <span class="math inline">\(R^2\)</span> は、従来の回帰で使われるものと若干異なることを示すために、アスタリスク (<span class="math inline">\(*\)</span>) を追加している。 <span class="math inline">\(R^2_*\)</span> の式は次のようになる。</p>
<p><span class="math display" id="eq:mr6">\[\begin{equation}
R^2_* = 1- \frac{\hat\tau^2_{\text{unexplained}}}{\hat\tau^2_{\text{(total)}}}
\tag{8.6}
\end{equation}\]</span></p>
<p><span class="math inline">\(R^2_*\)</span> は、メタ回帰の傾きでさえ説明できない異質性分散の残差量を使用し、それをメタ分析で最初に発見した異質性の合計で割る。この割合を1から引くと、予測変数によって説明される研究間の異質性のパーセンテージが得られる。</p>
<p>また、<span class="math inline">\(R^2_*\)</span> を定式化する別の方法がある。それは、混合効果モデルが、最初のランダム効果プーリングモデルと比較して、異質性の分散をどれだけ<strong>低減</strong>させるかをパーセントで表すと言うことができる。この結果、次のような式になる。</p>
<p><span class="math display" id="eq:mr7">\[\begin{equation}
R^2_* =  \frac{\hat\tau^2_{\text{REM}}-\hat\tau^2_{\text{MEM}}}{\hat\tau^2_{\text{REM}}}
\tag{8.7}
\end{equation}\]</span></p>
<p>この式で、<span class="math inline">\(\hat\tau^2_{\text{REM}}\)</span> はランダム効果プーリングモデルで見つかった研究間異質性の量を表し、<span class="math inline">\(\hat\tau^2_{\text{MEM}}\)</span> は混合効果メタ回帰モデルの (残) 分散 (すなわち、真の効果量に関する「予測誤差」) を表す。</p>
<p></p>
<p>通常、私たちは回帰モデルで説明される異質性の量に興味があるだけでなく、私たちの予測因子 <span class="math inline">\(x\)</span> の回帰重量が有意であるかどうかにも興味がある。もしそうであれば、<span class="math inline">\(x\)</span> が研究の効果量に影響を及ぼしていると確信できる。従来の回帰でもメタ回帰でも、回帰重みの有意性は、一般的に <strong>Wald-type</strong> 検定で評価される。これは、<span class="math inline">\(\beta\)</span> の推定値をその標準誤差で割ることによって、検定統計量 <span class="math inline">\(z\)</span> を計算することを含む。</p>
<p><span class="math display" id="eq:mr8">\[\begin{equation}
z = \frac{\hat\beta}{SE_{\hat\beta}}
\tag{8.8}
\end{equation}\]</span></p>
<p><span class="math inline">\(\beta = 0\)</span> という帰無仮説のもとでは、この <span class="math inline">\(z\)</span> -統計量は、標準正規分布に従う。これは、対応する <span class="math inline">\(p\)</span> -値を計算することができ、予測変数が有意であるかどうかを決定するものである。</p>
<p>しかし、<span class="math inline">\(z\)</span>-統計量に基づく検定は、予測変数の有意性を評価する唯一の方法ではない。通常のメタ分析モデルのように、<span class="math inline">\(t\)</span>-分布に基づく検定統計量になる Knapp-Hartung 調整も使用できる ( Chapter <a href="pooling-es.html#knapp-hartung">4.1.2.2</a> を参照)。以前学んだように、Knapp-Hartung 法は、偽陽性のリスクを減らすので、使用することが推奨される。</p>
<p><br></p>
</div>
</div>
<div id="metareg-R" class="section level2" number="8.2">
<h2>
<span class="header-section-number">8.2</span> <em>R</em> のメタ回帰について<a class="anchor" aria-label="anchor" href="#metareg-R"><i class="fas fa-link"></i></a>
</h2>
<hr>
<p><strong>{meta}</strong> パッケージには、メタ回帰を行うための関数 <code>metareg</code> が含まれている。この <code>metareg</code> 関数は、入力として <strong>{meta}</strong> メタ分析オブジェクトと共変量名のみを必要とする。</p>
<p>この例では、再び <code>ThirdWave</code> データセット ( Chapter <a href="pooling-es.html#pre-calculated-es">4.2.1</a> 参照) に基づいた <code>m.gen</code> メタ分析オブジェクトを使用する。メタ回帰を用いて、研究の<strong>出版年</strong>がその効果量を予測するのに使えるかどうかを調べたいと思われる。デフォルトでは、<code>ThirdWave</code> データセットには出版年を格納する変数がないので、この情報を格納する新しい <code>numeric</code> 変数を作成する必要がある。そのため、この情報を含む新しい <code>numeric</code> 変数を作成する必要がある。ここでは、すべての研究の出版年を <code>ThirdWave</code> データセットに現れるのと同じ順序で単純に連結している。この変数を <code>year</code><a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;この例で使用している出版年はテキトウで、説明のためだけに使用している。&lt;/p&gt;"><sup>31</sup></a> という名前で保存する。</p>
<div class="sourceCode" id="cb220"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">year</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2014</span>, <span class="fl">1998</span>, <span class="fl">2010</span>, <span class="fl">1999</span>, <span class="fl">2005</span>, <span class="fl">2014</span>, </span>
<span>          <span class="fl">2019</span>, <span class="fl">2010</span>, <span class="fl">1982</span>, <span class="fl">2020</span>, <span class="fl">1978</span>, <span class="fl">2001</span>,</span>
<span>          <span class="fl">2018</span>, <span class="fl">2002</span>, <span class="fl">2009</span>, <span class="fl">2011</span>, <span class="fl">2011</span>, <span class="fl">2013</span><span class="op">)</span></span></code></pre></div>
<p>これで、メタ回帰を実行するために必要な情報はすべて揃った。<code>metareg</code> 関数では、最初の引数にメタ分析オブジェクトの名前 <code>m.gen</code> を指定し、2番目の引数に予測変数の名前 <code>year</code> を指定する。結果は <code>m.gen.reg</code> という名前になる。</p>
<div class="sourceCode" id="cb221"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.gen.reg</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/meta/man/metareg.html">metareg</a></span><span class="op">(</span><span class="va">m.gen</span>, <span class="op">~</span><span class="va">year</span><span class="op">)</span></span></code></pre></div>
<p>では、その結果を見てみよう。</p>
<div class="sourceCode" id="cb222"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.gen.reg</span></span></code></pre></div>
<pre><code>## Mixed-Effects Model (k = 18; tau^2 estimator: REML)
## 
## tau^2 (estimated amount of residual heterogeneity):     0.019 (SE = 0.023)
## tau (square root of estimated tau^2 value):             0.1371
## I^2 (residual heterogeneity / unaccounted variability): 29.26%
## H^2 (unaccounted variability / sampling variability):   1.41
## R^2 (amount of heterogeneity accounted for):            77.08%
## 
## Test for Residual Heterogeneity:
## QE(df = 16) = 27.8273, p-val = 0.0332
## 
## Test of Moderators (coefficient 2):
## F(df1 = 1, df2 = 16) = 9.3755, p-val = 0.0075
## 
## Model Results:
## 
##         estimate     se   tval   pval    ci.lb    ci.ub 
## intrcpt   -36.15  11.98  -3.01  0.008  -61.551  -10.758  ** 
## year        0.01   0.00   3.06  0.007    0.005    0.031  ** 
## 
## ---
## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre>
<p></p>
<p>ここでわかることを見ていこう。最初の行では、意図したとおりに混合効果モデルがデータに適合されたことが出力されている。次の数行は、モデルによって説明される異質性の量に関する詳細である。残差異質性分散 (予測変数によって説明されない分散) の推定値が、<span class="math inline">\(\hat\tau^2_{\text{unexplained}}=\)</span> 0.019である。</p>
<p>出力には、<span class="math inline">\(I^2\)</span> もある。これは、予測変数の包含後、データの変動の29.26%が残りの研究間異質性に帰着することができることを教えてくれる。通常のランダム効果メタ分析モデルでは、<span class="math inline">\(I^2\)</span> 異質性が 63% であることがわかっていた。これは、予測変数が真の効果量における差のかなりの量を「説明する」ことができたということになる。</p>
<p>最後の行では、<span class="math inline">\(R^2_*\)</span> の値が表示され、この例では 77% となっている。これは、真の効果量の差の77%が出版年によって説明できることを意味し、非常に大きな値である。</p>
<p>次のセクションは、<code>Test for Residual Heterogeneity</code> を含み、本質的には、すでに以前知った <span class="math inline">\(Q\)</span>-検定である ( Chapter <a href="heterogeneity.html#cochran-q">5.1.1</a> を参照)。ここでは、予測変数で説明されない異質性が有意であるかどうかを検定する。<span class="math inline">\(p\)</span> = 0.03 であることから有意である。しかし、私たちは <span class="math inline">\(Q\)</span>-検定 (Chapter <a href="heterogeneity.html#cochran-q">5.1.1</a>) の限界を知っているので、この結果にはあまり依存しない方がよいだろう。</p>
<p>次の部分は、<code>Test of Moderators</code> を示している。この検定も有意であることがわかる (<span class="math inline">\(p\)</span> = 0.0075)。これは、私たちの予測因子である出版年が、実際に研究の効果量に影響を与えることを意味する。</p>
<p>最後のセクションでは、推定された回帰係数の詳細を説明する。最初の行は、切片 (<code>intrcpt</code>) の結果を示している。これは、予測因子である出版年がゼロの場合に期待される効果量 (私たちの場合: Hedges’ <span class="math inline">\(g\)</span>) である。この例では、少し不自然なシナリオを表している。これは、0年に実施された研究の予測効果を示しており、<span class="math inline">\(\hat{g}=\)</span> -36.15となっている。優れた統計モデルは現実を完璧に表現している必要はなく、ただ<strong>有用</strong>であればよいということを改めて思い起こさせるものとなっている。</p>
<p>私たちが主に注目するのは2行目の係数である。このモデルの <code>year</code> の回帰重みの推定値が0.01であることがわかる。これは、1年増えるごとに、研究の効果量 <span class="math inline">\(g\)</span> が0.01ずつ増加することを意味する。したがって、研究の効果量は時間とともに増加していると言えるだろう。95%信頼区間の範囲は 0.005 から 0.3 であり、効果は有意であることがわかる。</p>
<p>重要なのは、各回帰係数( <code>tval</code> )に対応する <span class="math inline">\(t\)</span>-統計量も提示されていることである。これは、信頼区間と <span class="math inline">\(p\)</span> -値を計算するために、Knapp-Hartung 法が使用されたことを示す。最初のメタ分析モデルでもこの調整法を使用したので、 <code>metareg</code> はここでも自動的にこの調整法を使用してきた。そうでなければ、<span class="math inline">\(z\)</span> 値と Wald 型信頼区間が提供されるはずであった。</p>
<p></p>
<p><strong>{meta}</strong> パッケージでは、 <code>bubble</code> 関数を用いてメタ回帰を可視化することができる。これは、推定回帰勾配と各研究の効果量を示す<strong>バブルプロット</strong> (bubble plot) を作成する。研究の重みを示すために、バブルは異なる大きさを持ち、大きければ大きいほど重みがあることを表す。</p>
<p>バブルプロットを作成するためには、メタ回帰オブジェクトを <code>bubble</code> 関数に接続するだけである。研究ラベルも表示させたいので、<code>studlab</code> を <code>TRUE</code> に設定する。</p>
<div class="sourceCode" id="cb224"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/meta/man/bubble.metareg.html">bubble</a></span><span class="op">(</span><span class="va">m.gen.reg</span>, studlab <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="Doing_Meta_Analysis_in_R_files/figure-html/bubble-1.png" width="60%" style="display: block; margin: auto;"></div>
<p></p>
<p>完全性を期すために、前章のサブグループ分析 (Chapter <a href="subgroup.html#subgroup-R">7.3</a>) を、今度はメタ回帰の枠組みで繰り返してみることもできる。これは、カテゴリ予測因子としてバイアスのリスク・アセスメントを使用することを意味する。変数 <code>RiskOfBias</code> はすでに <code>ThirdWave</code> のデータセットに含まれているので、この情報を追加オブジェクトに保存する必要はない。単純に <code>metareg</code> 関数を再度実行すれば良いのであるが、今回は関数の2番目の引数として <code>RiskOfBias</code> を使用する。</p>
<div class="sourceCode" id="cb225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/meta/man/metareg.html">metareg</a></span><span class="op">(</span><span class="va">m.gen</span>, <span class="va">RiskOfBias</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [...]
## R^2 (amount of heterogeneity accounted for):            15.66%
## 
## Test for Residual Heterogeneity:
## QE(df = 16) = 39.3084, p-val = 0.0010
## 
## Test of Moderators (coefficient 2):
## F(df1 = 1, df2 = 16) = 2.5066, p-val = 0.1329
## 
## Model Results:
## 
##               estimate    se   tval    pval  ci.lb ci.ub 
## intrcpt           0.76  0.15   5.00  0.0001   0.44  1.09  *** 
## RiskOfBiaslow    -0.29  0.18  -1.58  0.1329  -0.69  0.10      
## [...]
</code></pre>
<p>出力では、<span class="math inline">\(R^2_*\)</span> の値が15.66%で、<code>year</code> の値よりかなり小さいことがわかる。以前の結果と一致して、バイアス・リスク変数が有意な効果量予測因子でないことがわかる (<span class="math inline">\(p\)</span> = 0.13)。</p>
<p>モデル結果の下で、<code>metareg</code> が自動的に <code>RiskOfBias</code> をダミー変数に変換していることがわかる。サブグループ “high risk” のプール効果を表す切片の推定値は、<span class="math inline">\(g\)</span> = 0.76 である。バイアスのリスクが<strong>低い</strong>研究を表す回帰係数の推定値は -0.29 である。</p>
<p>このサブグループの効果量を得るには、切片に回帰重みを加える必要があり、その結果、<span class="math inline">\(g=\)</span> 0.76 - 0.29 <span class="math inline">\(\approx\)</span> 0.47 となる。これらの結果は、<span class="math inline">\(\tau^2\)</span> の共通の推定値を仮定したサブグループ分析の結果と同じである。</p>
<p><br></p>
</div>
<div id="multiple-metareg" class="section level2" number="8.3">
<h2>
<span class="header-section-number">8.3</span> 多重メタ回帰<a class="anchor" aria-label="anchor" href="#multiple-metareg"><i class="fas fa-link"></i></a>
</h2>
<hr>
<p></p>
<p>前回は、メタ回帰モデルで<strong>一つの</strong>の予測因子 <span class="math inline">\(\beta x_k\)</span> を使用するシナリオのみを検討してきた。この例では、研究の効果量が出版された年に依存するかどうかを調べる。しかし今度は、報告された効果量が、研究が掲載された科学雑誌の<strong>名声</strong>にも依存していると仮定しよう。高い評価を得ている雑誌に掲載された研究が、より高い効果を報告している可能性があると考えている。なぜなら、一流の雑誌では、選ばれた研究は「画期的」な発見をしていることがほとんどだからである。</p>
<p>一方、評判の良い雑誌は一般的に<strong>質の高い</strong>研究を掲載しているというのももっともな話である。もしかしたら、より高い効果量と関連するのは、より良い研究の質だけだろう。そこで、ジャーナルの評判が本当に高い効果と関連しているかどうかを確認するために、この関係が、一流のジャーナルが高品質のエビデンスを出版する可能性が高いという事実によって<strong>交絡</strong>していないことを確認する必要がある。つまり、ジャーナルの名声と効果量の関係を調査する際には、研究の質を<strong>コントロール</strong>する必要がある。</p>
<p>これや他の多くの研究課題は、<strong>多重メタ回帰</strong>を使用して対処することができる。多重メタ回帰では、効果の変動を説明するために、1つだけでなく複数の予測変数を使用する。複数の予測変数を使用できるようにするには、前のメタ回帰式 (式8.2参照) を修正して、次のようにする必要がある。</p>
<p><span class="math display" id="eq:mr10">\[\begin{equation}
\hat \theta_k = \theta + \beta_1x_{1k} + ... + \beta_nx_{nk} + \epsilon_k + \zeta_k
\tag{8.9}
\end{equation}\]</span></p>
<p>この式は、メタ回帰モデルに <span class="math inline">\(n-1\)</span> より多くの予測変数 <span class="math inline">\(x\)</span> を追加して、多重メタ回帰に変えることができることを示す。この式の3つの点は、理論的には、望むだけの予測変数を追加できることを象徴している。しかし、現実にはもっとやっかいなことが多い。以下では、多重メタ回帰のいくつかの重要な落とし穴と、どのようにすれば頑健で信頼できるモデルを構築できるかを説明する。その前に、多重メタ回帰のもう一つの重要な特徴である<strong>交互作用</strong> (interaction) について説明する。</p>
<p><br></p>
<div id="interact" class="section level3" number="8.3.1">
<h3>
<span class="header-section-number">8.3.1</span> 交互作用<a class="anchor" aria-label="anchor" href="#interact"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p></p>
<p>ここまでは、モデル内に複数の予測変数 <span class="math inline">\(x_1, x_2, \dots x_n\)</span> があり、それらの回帰重み <span class="math inline">\(\beta\)</span> と共に加算される場合のみを考えていた。しかし、多重メタ回帰モデルは、このような<strong>加算</strong>関係に限定されるわけではない。また、予測変数の<strong>交互作用</strong> もモデル化することができる。交互作用とは、ある予測変数 (例: <span class="math inline">\(x_1\)</span> ) と推定効果量との間の<strong>関係</strong>が、別の共変量 (例: <span class="math inline">\(x_2\)</span> ) の異なる値で<strong>変化する</strong>ことを意味する。</p>
<p>2つの予測因子とそれらが効果量とどのように関連するかをモデル化したいとする: 出版年 (<span class="math inline">\(x_1\)</span>) と研究の質 (<span class="math inline">\(x_2\)</span>) である。研究の質は次のようにコード化される。</p>
<p><span class="math display" id="eq:mr11">\[\begin{equation}
  x_2=\begin{cases}
    0: &amp; \text{low}\\
    1: &amp; \text{moderate}\\
    2: &amp; \text{high}
  \end{cases}
  \tag{8.10}
\end{equation}\]</span></p>
<p>出版年と研究の質の間に交互作用がないと仮定した場合、<span class="math inline">\(x_1\)</span> と <span class="math inline">\(x_2\)</span> の両方に回帰の重み <span class="math inline">\(\beta\)</span> を与え、数式でその項を一緒に<strong>追加</strong>することによって、メタ回帰モデルを構築することができる。</p>
<p><span class="math display" id="eq:mr12">\[\begin{equation}
\hat \theta_k = \theta + \beta_1x_{1k} + \beta_2x_{2k} + \epsilon_k + \zeta_k
\tag{8.11}
\end{equation}\]</span></p>
<p>しかし、<span class="math inline">\(x_1\)</span> と <span class="math inline">\(x_2\)</span> の関係がもっと複雑だとしたらどうだろうか。先ほどの例のように、より新しい出版年がより高い効果と正に関連している可能性がある。しかし、すべての研究がこのような傾向を示すとは限らない。もしかしたら、質の高い研究で顕著に増加し、質の低い研究の結果は時間の経過とともにほとんど変わらなくなるだろう。効果量 (<span class="math inline">\(\hat\theta_k\)</span>)、出版年 (<span class="math inline">\(x_1\)</span>)、研究の質 (<span class="math inline">\(x_2\)</span>)の間のこの想定された関係は、次のように可視化することができる。</p>
<div class="inline-figure"><img src="images/metareg2_col_sep.png" width="60%" style="display: block; margin: auto;"></div>
<p>このグラフは、交互作用の典型的な例を示している。回帰の傾きの急さは、別の予測変数の値に依存することがわかる。質の高い研究では、回帰線の傾きが非常に急で、発表年と効果の間に強い関係があることを示しているが、低質な研究では状況が異なる。このサブグループの回帰直線はほとんど水平で、出版年は結果に全く、あるいはわずかにマイナスの影響を与えることを示している。</p>
<p>この例は、交互作用の強みの1つである、予測因子の影響がすべての研究で同じかどうか、あるいは他の特性によって緩和されているかどうかを調べることができることを示している。</p>
<p>メタ回帰で交互作用を評価するためには、モデルに<strong>交互作用項</strong> を追加する必要がある。私たちの例では、これは私たちのモデルでテストしたい交互作用 <span class="math inline">\(x_{1k}x_{2k}\)</span> を捕捉する3番目の回帰重み <span class="math inline">\(\beta_3\)</span> を追加することで達成できる。これは、次の数式を与える。</p>
<p><span class="math display" id="eq:mr13">\[\begin{equation}
\hat \theta_k = \theta + \beta_1x_{1k} + \beta_2x_{2k} + \beta_3x_{1k}x_{2k}+ \epsilon_k + \zeta_k
\tag{8.12}
\end{equation}\]</span></p>
<p>線形多重メタ回帰モデルは、このような単純な構成要素で構成されているだけであるが、様々な用途に使用することができる。しかし、 <em>R</em> を用いた多重メタ回帰のフィッティングを始める前に、まずその限界と落とし穴について考えておく必要がある。</p>
<p><br></p>
</div>
<div id="limits-metareg" class="section level3" number="8.3.2">
<h3>
<span class="header-section-number">8.3.2</span> 多重メタ回帰にありがちな落とし穴<a class="anchor" aria-label="anchor" href="#limits-metareg"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>多重メタ回帰は、適切に適用されれば非常に有用であるが、ある種の注意点がある。実際には (多重) メタ回帰は不適切な使い方や解釈が多く、結果の妥当性が低いという意見もある <span class="citation">(<a href="references.html#ref-higgins2004controlling">JPT Higgins and Thompson 2004</a>)</span>。多重メタ回帰モデルを当てはめる際に注意しなければならない点がいくつかあるので、以下に説明する。</p>
<p><br></p>
<div id="過適合-シグナルのないところにシグナルを見いだす" class="section level4" number="8.3.2.1">
<h4>
<span class="header-section-number">8.3.2.1</span> 過適合: シグナルのないところにシグナルを見いだす<a class="anchor" aria-label="anchor" href="#%E9%81%8E%E9%81%A9%E5%90%88-%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB%E3%81%AE%E3%81%AA%E3%81%84%E3%81%A8%E3%81%93%E3%82%8D%E3%81%AB%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB%E3%82%92%E8%A6%8B%E3%81%84%E3%81%A0%E3%81%99"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p>メタ回帰モデル (複数) のリスクをより良く理解するためには、<strong>過適合</strong> (overfitting) という概念を理解する必要がある。過適合とは、データに<strong>あまりにも</strong>近く適合するような統計モデルを構築した場合に起こる。簡単に説明すると、手元のデータはうまく予測できるが、将来のデータはうまく予測できない統計モデルを構築してしまうということである。</p>
<p>これは、モデルが、データの変動が真の「シグナル」に由来すると仮定したときに起こるもので、実際にはランダムなノイズしか捉えていない <span class="citation">(<a href="references.html#ref-iniesta2016machine">Iniesta, Stahl, and McGuffin 2016</a>)</span>。その結果、モデルは<strong>偽陽性</strong>の結果を生成する。つまり、何もないところに関係性を見出すのである。</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:overfitting"></span>
<img src="images/overfitting_col_sep.png" alt="過適合モデルと頑健適合モデルの予測。" width="80%"><p class="caption">
Figure 8.3: 過適合モデルと頑健適合モデルの予測。
</p>
</div>
<p>
</p>
<p>モデル適合のために、回帰は通常の最小二乗法や最尤推定などの<strong>最適化</strong>技術を利用する。すでに学んだように、メタ回帰は普通の最小二乗法の重み付きバージョンを使用するので (Chapter <a href="metareg.html#metareg-model-fit">8.1.3</a> 参照)、これも例外ではない。</p>
<p>「貪欲に」最適化すると、回帰アプローチは過適合に陥りやすい <span class="citation">(<a href="references.html#ref-gigerenzer2004mindless">Gigerenzer 2004</a>)</span>。残念ながら、従来の回帰手法からメタ回帰に移行すると、頑健でないモデルを構築するリスクはさらに高くなる。これにはいくつかの理由がある <span class="citation">(<a href="references.html#ref-higgins2004controlling">JPT Higgins and Thompson 2004</a>)</span>。</p>
<ol style="list-style-type: decimal">
<li><p>メタ回帰では、含まれる研究の集約された情報しか使えないので、通常、データポイントの数は少ない。</p></li>
<li><p>メタ分析は、すべての利用可能なエビデンスを包括的に概観することを目的としているので、回帰モデルが未知のデータをどれだけ予測できるかを「テスト」できるような追加データが存在しない。</p></li>
<li><p>メタ回帰では、効果量の異質性が存在する可能性に対処しなければならない。２つの研究があり、両者の効果量が異なり、信頼区間が重なっていないケースを想像してみよう。２つの研究で異なる値を持つすべての変数が、効果量の差の説明となり得る。しかし、これらの説明のほとんどが偽の説明であることは明らかだろう。</p></li>
<li><p>一般的なメタ回帰、特に多重メタ回帰は、予測変数の「遊び」を非常に簡単にする。データの異質性を説明するために、多数のメタ回帰モデルをテストして、より多くの予測変数を含めたり削除したりすることができる。このアプローチは魅力的で、実際によく見られる。メタ分析では、効果量が異なる理由の説明を見つけたいからである <span class="citation">(<a href="references.html#ref-higgins2002statistical">J. Higgins et al. 2002</a>)</span>。有意なモデルを見つけるまで無限にモデルの一部を変更することができるが、そのモデルは過適合である (つまり、ほとんど統計的ノイズをモデル化している) 可能性が非常に高い。</p></li>
</ol>
<p>メタ回帰モデルを構築する際に、過度の偽陽性を避けるためのガイドラインがいくつか提案されている。</p>
<p>
</p>
<ul>
<li><p>調査すべき予測変数の数を最小にする。多重メタ回帰では、これは<strong>倹約</strong> (parsimony) の概念に変換される。つまり、メタ回帰モデルの適合を評価するとき、<strong>少ない</strong>予測変数で<strong>良い</strong>適合を達成するモデルを好む。赤池情報量規準やベイズ情報量規準のような推定量は、この決定を助けることができる。本章の実践例で、これらのメトリックをどのように解釈するかを示す。</p></li>
<li><p>予測変数の選択は、あらかじめ定義され、科学的に関連性のある、メタ分析で答えたい質問に基づいて行う必要がある。メタ分析モデルに含まれる予測因子 (組み合わせ) を分析レポート (Chapter <a href="intro.html#analysis-plan">1.4.2</a> ) ですでに定義しておくことが重要である。分析計画に記載されていないメタ分析を実行することになったとしても、それで終わりではない。ただし、この場合は正直に、メタ分析報告書に、データを見た<strong>後で</strong>モデルの適合を決定したことを記載する必要がある。</p></li>
<li><p>研究数が少ない場合 (これはよくある)、予測変数の有意性を計算したい場合は、Knapp-Hartung 調整を用いて、より頑健な推定値を得るべきである。</p></li>
</ul>
<p></p>
<ul>
<li>再サンプルされたデータにおけるモデルの頑健性を評価するために、<strong>置換</strong>を使用することができる。この方法の詳細については後ほど説明する。</li>
</ul>
<p><br></p>
</div>
<div id="多重共線性" class="section level4" number="8.3.2.2">
<h4>
<span class="header-section-number">8.3.2.2</span> 多重共線性<a class="anchor" aria-label="anchor" href="#%E5%A4%9A%E9%87%8D%E5%85%B1%E7%B7%9A%E6%80%A7"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p>
</p>
<p><strong>多重共線性</strong> (multi-collinearity) とは、回帰モデル中の1つ以上の予測変数が、他のモデル予測変数によって高い精度で予測されることである <span class="citation">(<a href="references.html#ref-mansfiled1982detecting">Mansfield and Helms 1982</a>)</span>。これは通常、モデル中に相関の高い２つ以上の独立変数があることを意味する。</p>
<p>多重共線性の危険性のほとんどは、過適合の問題と関連している。高い共線性は、予測変数の係数推定値 <span class="math inline">\(\hat\beta\)</span> を不安定にさせ、データの小さな変化で大きく変化させることがある。また、モデルによって説明される分散の大きさ (ここでは <span class="math inline">\(R^2_*\)</span>) も制限される。</p>
<p>メタ回帰における多重共線性は一般的である <span class="citation">(<a href="references.html#ref-berlin1994advantages">Berlin and Antman 1994</a>)</span>。重回帰は低度の共線性を扱うことができるが、非常に高い相関を持つ予測変数をチェックし、必要ならコントロールする必要がある。多重共線性の有無を判断するための統合されたイエス・ノールールはない。</p>
<p>モデルを適合する前に、非常に高い予測変数の相関 (すなわち、<span class="math inline">\(r \geq\)</span> 0.8) をチェックすることは、粗雑ではあるものの効果的な方法である。そして、多重共線性は、(1) 近い冗長な予測変数の１つを除去するか、(2) 予測変数を１つの単一変数に結合しようとするかのいずれかによって削減することができる。</p>
<p><br></p>
</div>
<div id="過適合のアプローチ" class="section level4" number="8.3.2.3">
<h4>
<span class="header-section-number">8.3.2.3</span> 過適合のアプローチ<a class="anchor" aria-label="anchor" href="#%E9%81%8E%E9%81%A9%E5%90%88%E3%81%AE%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p>多重メタ回帰モデルを構築するとき、予測変数の選択と包含にさまざまなアプローチがある。ここでは、最も重要なものを、その長所と短所とともに議論する。</p>
<ul>
<li><p><strong>強制投入</strong>. 強制投入法 (または変数指定法) では、すべての関連する予測変数が同時に回帰モデルに強制投入される。 <em>R</em> のほとんどの関数では、これはデフォルトの設定である。これは一般的に推奨される手順であるが、強制投入で使用するすべての予測変数は、やはり事前に定義された、理論に基づいた決定に基づいているべきであることに留意する必要がある。</p></li>
<li><p><strong>階層的</strong>. 階層的重回帰は、明確に定義された科学的根拠に基づいて、予測変数を段階的に私たちの回帰モデルに含めることを意味する。まず、以前の研究で効果量の差に関係していた予測変数のみが、その重要性の順序で含まれる。このステップの後、既知の予測変数ではまだ捕捉されていない異質性をこれらの変数が説明するかどうかを調べるために、新しい予測変数を追加することができる。</p></li>
</ul>
<p></p>
<ul>
<li>
<strong>ステップ・ワイズ</strong>. ステップ・ワイズ投入法 (または逐次選択法) とは、変数/予測変数が次々にモデルに追加されることを意味する。一見すると、これは階層的回帰とよく似ているが、決定的な違いがある: ステップ・ワイズ回帰法は、<strong>統計的基準</strong>に基づいて予測変数を選択する。<strong>変数増加法</strong> (前方選択、フォワード選択、forward selection) と呼ばれる手順では、データ中の最大の変動量を説明する変数が、最初の予測変数として使われる。そして、このプロセスを残りの変数について繰り返し、毎回、データ中の説明できない残留変動のほとんどを説明する変数を選択する。また、<strong>変数減少法</strong> (後方選択法、backward selection) と呼ばれる手順もあり、まずすべての変数がモデルの予測変数として使用され、次にあらかじめ定義された統計的基準に基づいて、順次削除される。ステップ・ワイズ法の使用を推奨しない文献が多数ある <span class="citation">(<a href="references.html#ref-chatfield1995model">Chatfield 1995</a>; <a href="references.html#ref-whittingham2006we">Whittingham et al. 2006</a>)</span>。上で示した重回帰モデルの一般的な落とし穴を思い出すと、これらの方法が偽の知見を持つ過剰適合モデルを生成する高いリスクを持つことが明らかになる。とはいえ、ステップワイズ法は今でも実務で頻繁に使われているので、これらの手続きが存在することを知っておくことは重要である。ただし、ステップワイズ法を使う場合は、主に探索的に行い、この手法の限界を念頭に置いておくことを勧める。(訳注: これらのほか、変数増減法、変数減増法がある。)</li>
</ul>
<p></p>
<ul>
<li>
<strong>マルチモデル推論</strong>. マルチモデル法 (または総当たり法) は、分散の大部分を説明する1つの「最良」モデルを連続的に構築しようとしないので、段階的アプローチとは異なる。その代わりに、この手法では、予測変数の<strong>すべての</strong>可能な組み合わせがモデル化される。これは、いくつかの異なるメタ回帰が作成され、その後、評価されることを意味する。これは、すべての可能な予測変数の組み合わせと、それらがどのように機能するかを完全に調べることができる。共通の発見は、良いモデル適合をもたらす多くの異なる仕様があることである。そして、予測変数の推定係数は、適合したすべてのモデルにわたってプールされ、特定の変数が全体としてどのくらい重要であるかを推論することができる。</li>
</ul>
<p><br></p>
</div>
</div>
<div id="multiple-metareg-R" class="section level3" number="8.3.3">
<h3>
<span class="header-section-number">8.3.3</span> <em>R</em> の多重メタ回帰<a class="anchor" aria-label="anchor" href="#multiple-metareg-R"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>
</p>
<p>すべてのインプットの後、 <em>R</em> を使用して最初の多重メタ回帰の適合を開始する時が来た。以下の例は、<strong>{meta}</strong> パッケージを使用しない最初の例である。その代わりに <strong>{metafor}</strong> を見てみよう <span class="citation">(<a href="references.html#ref-urviecht">Viechtbauer 2010</a>)</span>。このパッケージは、メタ分析のための膨大で高度な機能を、素晴らしいドキュメントとともに提供している<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;実際、メタ回帰を行うために、&lt;strong&gt;{meta}&lt;/strong&gt; 関数も内部で &lt;strong&gt;{metafor}&lt;/strong&gt; パッケージを使用している&lt;/p&gt;"><sup>32</sup></a>。そこで、まず、<strong>{metafor}</strong> がインストールされており、ライブラリからロードされていることを確認する。</p>
<div class="sourceCode" id="cb227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://www.metafor-project.org">metafor</a></span><span class="op">)</span></span></code></pre></div>
<p>このハンズオンでは、 <code>MVRegressionData</code> データセットを使用する。これは「おもちゃ」のようなデータセットで、説明のためにシミュレートしたものである。</p>
<p></p>
<div class="boxdmetar">
<p>
<strong>“MVRegressionData” データセット</strong>
</p>
<p>
<code>MVRegressionData</code> のデータセットも
<strong>{dmetar}</strong>
パッケージに直接含まれている。<strong>{dmetar}</strong>
をインストールし、ライブラリからロードした後、
<code>data(SuicidePrevention)</code> を実行すると、自動的に <em>R</em>
環境にデータセットが保存される。これでデータセットが利用できる。もし、<strong>{dmetar}</strong>
がインストールされていない場合は、<a href="https://www.protectlab.org/meta-analysis-in-r/data/MVRegressionData.rda">インターネット</a>から
<em>.rda</em>
ファイルとしてデータセットをダウンロードして作業ディレクトリに保存し、R
Studio ウィンドウでクリックするとインポートすることができる。
</p>
</div>
<p>まず、データフレームの構造を見てみよう。</p>
<div class="sourceCode" id="cb228"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://tidyverse.tidyverse.org">tidyverse</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://dmetar.protectlab.org">dmetar</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">MVRegressionData</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://pillar.r-lib.org/reference/glimpse.html">glimpse</a></span><span class="op">(</span><span class="va">MVRegressionData</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Rows: 36
## Columns: 6
## $ yi         &lt;dbl&gt; 0.09437543, 0.09981923, 0.16931607, 0.17511107, 0.27301641,…
## $ sei        &lt;dbl&gt; 0.1959031, 0.1918510, 0.1193179, 0.1161592, 0.1646946, 0.17…
## $ reputation &lt;dbl&gt; -11, 0, -11, 4, -10, -9, -8, -8, -8, 0, -5, -5, -4, -4, -3,…
## $ quality    &lt;dbl&gt; 6, 9, 5, 9, 2, 10, 6, 3, 10, 3, 1, 5, 10, 2, 1, 2, 4, 1, 8,…
## $ pubyear    &lt;dbl&gt; -0.85475360, -0.75277184, -0.66048349, -0.56304843, -0.4308…
## $ continent  &lt;fct&gt; 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,…</code></pre>
<p>このデータセットには6つの変数があることがわかる。<code>yi</code> 列と <code>sei</code> 列は、特定の研究の効果量と標準誤差を格納する。この列は、前に使った <code>TE</code> 列と <code>seTE</code> 列と対応している。この変数名が、<strong>{metafor}</strong> が使用している標準的な表記方法である。<code>yi</code> は (メタ) 回帰で予測したい観測された効果量 <span class="math inline">\(y_i\)</span> を表し、<code>sei</code> は <span class="math inline">\(SE_i\)</span>で、研究 <span class="math inline">\(i\)</span> の標準誤差を表す。</p>
<p>他の4つの変数は、メタ回帰で使用される予測変数である。まず、<code>reputation</code> であるが、これは研究が掲載されたジャーナルの (平均値中心の) <strong>インパクト・ファクター</strong>である。インパクトファクターは、ジャーナルの論文がどれだけ頻繁に引用されるかを定量化し、ジャーナルの名声の代理として使用する。</p>
<p>その他の変数は、0 から 10 で評価される研究の質である <code>quality</code>、(平均値中心揃えでスケーリングされた) 出版年である <code>pubyear</code>、そして研究が行われた大陸である <code>continent</code> である。これらの変数は、<code>continent</code> を除き、すべて連続変数である。<code>continent</code> は、ヨーロッパと北アメリカの2つのレベルを持つカテゴリ変数である。</p>
<p><br></p>
<div id="多重共線性の確認" class="section level4" number="8.3.3.1">
<h4>
<span class="header-section-number">8.3.3.1</span> 多重共線性の確認<a class="anchor" aria-label="anchor" href="#%E5%A4%9A%E9%87%8D%E5%85%B1%E7%B7%9A%E6%80%A7%E3%81%AE%E7%A2%BA%E8%AA%8D"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p>前に述べたように、メタ回帰の係数推定が頑健 (robust) であることを確認するために、予測変数の多重共線性をチェックする必要がある。高い相関をチェックする簡単な方法は、すべての連続変数について<strong>相互相関行列</strong>を計算することである。これは、<code>cor</code> 関数を用いて行うことができる。</p>
<div class="sourceCode" id="cb230"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MVRegressionData</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"reputation"</span>, <span class="st">"quality"</span>, <span class="st">"pubyear"</span><span class="op">)</span><span class="op">]</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code>##            reputation    quality    pubyear
## reputation  1.0000000  0.3015694  0.3346594
## quality     0.3015694  1.0000000 -0.1551123
## pubyear     0.3346594 -0.1551123  1.0000000</code></pre>
<p></p>
<p><strong>{PerformanceAnalytics}</strong> パッケージ <span class="citation">(<a href="references.html#ref-perfanalytics">Peterson and Carl 2020</a>)</span> には <code>chart.Correlation</code> という関数があり、これを使うと相関行列を可視化することができる。まず、<code>PerformanceAnalytics</code> パッケージをインストールしてから、このコードを使用する必要がある。</p>
<div class="sourceCode" id="cb232"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/braverock/PerformanceAnalytics">PerformanceAnalytics</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">MVRegressionData</span><span class="op">[</span>,<span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"reputation"</span>, <span class="st">"quality"</span>, <span class="st">"pubyear"</span><span class="op">)</span><span class="op">]</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html">%&gt;%</a></span> </span>
<span>  <span class="fu"><a href="https://rdrr.io/pkg/PerformanceAnalytics/man/chart.Correlation.html">chart.Correlation</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="Doing_Meta_Analysis_in_R_files/figure-html/unnamed-chunk-197-1.png" width="60%" style="display: block; margin: auto;"></div>
<p>変数は確かに相関しているが、おそらくそのうちの 1 つを除外するほどではないだろうということがわかる。</p>
<p><br></p>
</div>
<div id="多重メタ回帰モデルの適合" class="section level4" number="8.3.3.2">
<h4>
<span class="header-section-number">8.3.3.2</span> 多重メタ回帰モデルの適合<a class="anchor" aria-label="anchor" href="#%E5%A4%9A%E9%87%8D%E3%83%A1%E3%82%BF%E5%9B%9E%E5%B8%B0%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E9%81%A9%E5%90%88"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p>さて、最初のメタ回帰モデルは、 <strong>{metafor}</strong> を使用して適合させることができる。以前は、高いジャーナルの評判がより高い効果量を予測するかどうか、またはこれが単に一流ジャーナルの研究がより高い品質を持つという事実によって引き起こされる思い込みであるかどうかを調べたいと思った。</p>
<p>例えば、先行研究から研究の質が効果量を予測することがよく分かっていると仮定しよう。この場合、階層的回帰を実行することは理にかなっている。まず、既知の予測因子である「品質」を含め、次に「評判」がそれ以上の異質性を説明するかどうかをチェックする。これが正しい場合、一流雑誌の研究がより高い品質を持つ傾向があるという事実を<strong>制御</strong>しても、雑誌の評判は実際に高い効果と関連していると言うことができる。</p>
<p>そのために、 <strong>{metafor}</strong> の <code>rma</code> 関数を使用する。この関数はランダム効果メタ分析を実行し、モデレータが追加されると混合効果メタ回帰モデルへと拡張される。<code>rma</code> 関数は無数の引数を取ることができ、 <em>R</em> コンソールで <code><a href="https://wviechtb.github.io/metafor/reference/rma.uni.html">?rma</a></code> を実行すると、その引数を調べることができる。しかし、通常はそのうちのいくつかを指定するだけでよい。</p>
<ul>
<li><p><strong><code>yi</code></strong>. 各研究の効果量が格納されているデータフレームの列。</p></li>
<li><p><strong><code>sei</code></strong>. 各研究の効果量の標準誤差が格納されているデータフレームの列。</p></li>
<li><p><strong><code>data</code></strong>. メタ分析データを格納したデータフレーム名。</p></li>
<li><p><strong><code>method</code></strong>. 使用したい <span class="math inline">\(\tau^2\)</span> 推定量。この引数に使用できるコードは、 <strong>{meta}</strong> のものと同じである (例: <code>"REML"</code> restricted maximum likelihood の略)。<code>"ML"</code>を使用することが推奨される。これは、後で異なるメタ回帰モデルを比較することができるからである。</p></li>
<li><p><strong><code>mods</code></strong>. このパラメータは、メタ回帰モデルを定義する。まず、モデルを <code>~</code> (チルダ) で指定する。次に、含める予測変数を <code>+</code> で区切って追加する (例: <code>variable1 + variable2</code> )。2 つの変数の間の交互作用は、アスタリスクで表す (例: <code>variable1 * variable2</code> )。</p></li>
<li><p><strong><code>test</code></strong>. 回帰係数に適用したい検定である。デフォルトの <code>"z"</code> または <code>"knha"</code> (Knapp-Hartung method) から選択できる。</p></li>
</ul>
<p>まず、予測因子として <code>quality</code> だけを用いてメタ回帰を実行してみよう。その結果を <code>m.qual</code> というオブジェクトに保存して、出力を調べてみる。</p>
<div class="sourceCode" id="cb233"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.qual</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://wviechtb.github.io/metafor/reference/rma.uni.html">rma</a></span><span class="op">(</span>yi <span class="op">=</span> <span class="va">yi</span>,</span>
<span>              sei <span class="op">=</span> <span class="va">sei</span>,</span>
<span>              data <span class="op">=</span> <span class="va">MVRegressionData</span>,</span>
<span>              method <span class="op">=</span> <span class="st">"ML"</span>,</span>
<span>              mods <span class="op">=</span> <span class="op">~</span> <span class="va">quality</span>,</span>
<span>              test <span class="op">=</span> <span class="st">"knha"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">m.qual</span></span></code></pre></div>
<pre><code>## Mixed-Effects Model (k = 36; tau^2 estimator: ML)
## 
## tau^2 (estimated amount of residual heterogeneity):     0.066 (SE = 0.023)
## tau (square root of estimated tau^2 value):             0.2583
## I^2 (residual heterogeneity / unaccounted variability): 60.04%
## H^2 (unaccounted variability / sampling variability):   2.50
## R^2 (amount of heterogeneity accounted for):            7.37%
## 
## Test for Residual Heterogeneity:
## QE(df = 34) = 88.6130, p-val &lt; .0001
## 
## Test of Moderators (coefficient 2):
## F(df1 = 1, df2 = 34) = 3.5330, p-val = 0.0688
## 
## Model Results:
## 
##          estimate      se    tval    pval    ci.lb   ci.ub 
## intrcpt    0.3429  0.1354  2.5318  0.0161   0.0677  0.6181  * 
## quality    0.0356  0.0189  1.8796  0.0688  -0.0029  0.0740  . 
## 
## ---
## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre>
<p>この出力では、予測変数 <code>quality</code> の結果を <code>Model Results</code> の下で確認できる。トレンド・レベルでは有意であるが (<span class="math inline">\(p&lt;\)</span> 0.1)、回帰の重みは有意ではない (<span class="math inline">\(p=\)</span> 0.069)。合計で、このモデルは異質性の <span class="math inline">\(R^2_*=\)</span> 7.37% を説明する。</p>
<p>では、<code>reputation</code> を予測変数に含めるとどうなるか見てみよう。<code>mods</code> の入力に <code>+ reputation</code> を追加し、今回は出力を <code>m.qual.rep</code> として保存する。</p>
<div class="sourceCode" id="cb235"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.qual.rep</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://wviechtb.github.io/metafor/reference/rma.uni.html">rma</a></span><span class="op">(</span>yi <span class="op">=</span> <span class="va">yi</span>, </span>
<span>                  sei <span class="op">=</span> <span class="va">sei</span>, </span>
<span>                  data <span class="op">=</span> <span class="va">MVRegressionData</span>, </span>
<span>                  method <span class="op">=</span> <span class="st">"ML"</span>, </span>
<span>                  mods <span class="op">=</span> <span class="op">~</span> <span class="va">quality</span> <span class="op">+</span> <span class="va">reputation</span>, </span>
<span>                  test <span class="op">=</span> <span class="st">"knha"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">m.qual.rep</span></span></code></pre></div>
<pre><code>## Mixed-Effects Model (k = 36; tau^2 estimator: ML)
## 
## tau^2 (estimated amount of residual heterogeneity):     0.0238 (SE = 0.01)
## tau (square root of estimated tau^2 value):             0.1543
## I^2 (residual heterogeneity / unaccounted variability): 34.62%
## H^2 (unaccounted variability / sampling variability):   1.53
## R^2 (amount of heterogeneity accounted for):            66.95%
## 
## Test for Residual Heterogeneity:
## QE(df = 33) = 58.3042, p-val = 0.0042
## 
## Test of Moderators (coefficients 2:3):
## F(df1 = 2, df2 = 33) = 12.2476, p-val = 0.0001
## 
## Model Results:
## 
##             estimate      se    tval    pval    ci.lb   ci.ub 
## intrcpt       0.5005  0.1090  4.5927  &lt;.0001   0.2788  0.7222  *** 
## quality       0.0110  0.0151  0.7312  0.4698  -0.0197  0.0417      
## reputation    0.0343  0.0075  4.5435  &lt;.0001   0.0189  0.0496  *** 
## 
## ---
## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre>
<p>モデル結果のセクションに新しい行が表示され、予測変数 <code>reputation</code> の結果が表示されていることがわかる。モデルは、回帰の重みを 0.034 と推定し、これは非常に有意である (<span class="math inline">\(p\)</span> &lt; 0.001)。</p>
<p>また、メタ回帰モデルは、全体としてかなりの量の異質性を説明していることがわかる。正確には、<span class="math inline">\(R^2_*\)</span> = 66.95% である。これは、研究の質でコントロールした場合でも、ジャーナルの評判がより高い効果量と関連していることを意味する。</p>
<p>
</p>
<p>しかし、2番目のモデルは本当に最初のモデルよりも適合度が高いのだろうか？これを評価するために、 <code>anova</code> 関数を使用し、比較したい2つのモデルを指定することができる。これは、制限付き最尤法 (<code>"REML"</code>) の代わりに最尤法 (<code>"ML"</code>) を用いて両方の混合効果モデルを適合させたからこそ可能なことであることに注意しておこう。</p>
<div class="sourceCode" id="cb237"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/anova.html">anova</a></span><span class="op">(</span><span class="va">m.qual</span>, <span class="va">m.qual.rep</span><span class="op">)</span></span></code></pre></div>
<pre><code>##         df   AIC   BIC  AICc logLik   LRT   pval    QE tau^2    R^2 
## Full     4 19.86 26.19 21.15  -5.93              58.30  0.03          
## Reduced  3 36.98 41.73 37.73 -15.49 19.11 &lt;.0001 88.61  0.06 48.32% </code></pre>
<p>この関数はモデルのテストを行い、<code>m.qual.rep</code> が <code>m.qual</code> よりも適合度が高いかどうかを評価するためのいくつかの統計情報を提供する。ここでは、<code>quality</code> と <code>reputation</code> の両方を含むフルモデルである <code>m.qual.rep</code> と、<code>quality</code> のみを含む縮小モデルとを比較する。</p>
<p></p>
<p><code>anova</code> 関数は <strong>尤度比検定</strong>を実行し、その結果は <code>LRT</code> 列で見ることができる。この検定は非常に有意であり (<span class="math inline">\(\chi^2_1=\)</span> 19.11, <span class="math inline">\(p&lt;\)</span> 0.001)、フルモデルが本当に良い適合を提供することを意味する。</p>
<p></p>
<p>もう1つの重要な統計量は <code>AICc</code> 列で報告されていて、小さなサンプルで補正された赤池情報量規準 (AIC) を提供する。前に述べたように、AICc は、過適合を避けるために、より多くの予測変数がある複雑なモデルにペナルティを課す。</p>
<p>AIC の値が低いと、モデルの性能が良いということに注意を払うことが重要である。この出力では、より多くのパラメータがあるにもかかわらず、フルモデル (AICc = 21.15) が削減モデル (AICc = 37.73) よりも良いAIC値を持っていることがわかる。これらのことは、重回帰モデルが実際に私たちのデータに対して良い適合を提供することを示唆している。</p>
<p><br></p>
</div>
<div id="モデリング交互作用" class="section level4" number="8.3.3.3">
<h4>
<span class="header-section-number">8.3.3.3</span> モデリング交互作用<a class="anchor" aria-label="anchor" href="#%E3%83%A2%E3%83%87%E3%83%AA%E3%83%B3%E3%82%B0%E4%BA%A4%E4%BA%92%E4%BD%9C%E7%94%A8"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p>追加予測変数 <code>pubyear</code> (出版年) と <code>continent</code> との交互作用をモデル化したいとする。出版年と効果量の関係がヨーロッパと北米の研究で異なると仮定する。この仮定を <code>rma</code> 関数でモデル化するために、<code>mods</code> パラメータで予測変数を <code>*</code> と接続する必要がある。<code>anova</code> 関数を用いて直接モデルを比較したくないので、今回は <code>"REML"</code> (restricted maximum likelihood) <span class="math inline">\(\tau^2\)</span> 予測因子を使用する。</p>
<p>解釈を容易にするために、モデルを実行する前に <code>MVRegressionData</code> で <code>continent</code> 変数に因子ラベルを追加する。</p>
<div class="sourceCode" id="cb239"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 因子ラベルを 'continent' に追加</span></span>
<span><span class="co"># 0 = Europe</span></span>
<span><span class="co"># 1 = North America</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/levels.html">levels</a></span><span class="op">(</span><span class="va">MVRegressionData</span><span class="op">$</span><span class="va">continent</span><span class="op">)</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Europe"</span>, <span class="st">"North America"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># メタ回帰モデルを適合</span></span>
<span><span class="va">m.qual.rep.int</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://wviechtb.github.io/metafor/reference/rma.uni.html">rma</a></span><span class="op">(</span>yi <span class="op">=</span> <span class="va">yi</span>, </span>
<span>                      sei <span class="op">=</span> <span class="va">sei</span>, </span>
<span>                      data <span class="op">=</span> <span class="va">MVRegressionData</span>, </span>
<span>                      method <span class="op">=</span> <span class="st">"REML"</span>, </span>
<span>                      mods <span class="op">=</span> <span class="op">~</span> <span class="va">pubyear</span> <span class="op">*</span> <span class="va">continent</span>, </span>
<span>                      test <span class="op">=</span> <span class="st">"knha"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">m.qual.rep.int</span></span></code></pre></div>
<pre><code>## Mixed-Effects Model (k = 36; tau^2 estimator: REML)
## 
## tau^2 (estimated amount of residual heterogeneity):     0 (SE = 0.01)
## tau (square root of estimated tau^2 value):             0
## I^2 (residual heterogeneity / unaccounted variability): 0.00%
## H^2 (unaccounted variability / sampling variability):   1.00
## R^2 (amount of heterogeneity accounted for):            100.00%
## 
## Test for Residual Heterogeneity:
## QE(df = 32) = 24.8408, p-val = 0.8124
## 
## Test of Moderators (coefficients 2:4):
## F(df1 = 3, df2 = 32) = 28.7778, p-val &lt; .0001
## 
## Model Results:
## 
##                       estimate    se  tval    pval  ci.lb ci.ub 
## intrcpt                    0.38  0.04  9.24  &lt;.0001   0.30  0.47  *** 
## pubyear                    0.16  0.08  2.01  0.0520  -0.00  0.33    . 
## continentNorth America     0.39  0.06  6.05  &lt;.0001   0.26  0.53  *** 
## pubyear:continent          0.63  0.12  4.97  &lt;.0001   0.37  0.89  *** 
##    North America
## [...]</code></pre>
<p>最後の行の <code>pubyear:continentNorth America</code> には、交互作用項の係数が格納されている。 <strong>{metafor}</strong> は、自動的に交互作用項だけでなく、「通常の」低次予測変数として <code>pubyear</code> と <code>continent</code> の両方を含むことに注意しておこう (むしろ、注意すべき)。</p>
<p>また、<code>continent</code> は因子であるため、<code>rma</code> はこれがダミーコード化された予測因子であることを検出し、北米のカテゴリーと比較するために、カテゴリー「ヨーロッパ」を <span class="math inline">\(D_g\)</span> = 0 の基準として使用したことに留意してみよう。この交互作用項は正の係数 (0.63) を持ち、非常に有意であることがわかる (<span class="math inline">\(p&lt;\)</span> 0.001)。</p>
<p>これは、近年、効果量が増加していること、また、北米で行われた研究でより強くなっていることを示している。また、私たちがあてはめたモデルは、<span class="math inline">\(R^2_*\)</span> =100% の異質性を説明していることがわかる。</p>
<p>なぜこうなったかというと、このデータが説明のためにシミュレーションされたためである。実際には、データの異質性をすべて説明することはほとんどない。むしろ、現実のデータでこのような結果を見つけたら、モデルを過剰に適合させたことになるかもしれないので、心配する必要がある。</p>
<p><br></p>
</div>
<div id="並び替え検定" class="section level4" number="8.3.3.4">
<h4>
<span class="header-section-number">8.3.3.4</span> 並び替え検定<a class="anchor" aria-label="anchor" href="#%E4%B8%A6%E3%81%B3%E6%9B%BF%E3%81%88%E6%A4%9C%E5%AE%9A"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p><strong>並び替え</strong> (permutation) とは、数値や物体を含む集合を取り出し、その集合から繰り返し要素を取り出して順番に並べる数学的な操作である。すでに順序のある数値の集合がある場合、これはデータの順序を並べ替える、つまり<strong>シャッフル</strong>する処理と同じである。</p>
<p>例として、3つの数を含む集合 <span class="math inline">\(S=\{1,2,3 \}\)</span> があるとする。この集合の可能な並べ換えの1つは <span class="math inline">\((2,1,3)\)</span> 、別の並べ替えでは <span class="math inline">\((3,2,1)\)</span> となる。並べ替えの結果は、両方とも前の3つの数字を含んでいるが、順番が違うことがわかる。</p>
<p>並び替えは<strong>並び替え検定</strong>にも使われるが、リサンプリング法の特別な種類である。大まかに言うと、リサンプリング法は、同じソースまたは生成プロセスからサンプルされた (少し) 異なるデータを与えることによって、統計モデルの頑健性を検証するために使用される <span class="citation">(<a href="references.html#ref-good2013permutation">Good 2013, chap. 3.1</a>)</span>。これは、モデルの係数が本当にデータの根底にある真のパターンを捉えているかどうか、あるいは、モデルを過適合させ、それによって、実際には統計的ノイズであるのに、データのパターンを誤って仮定していないかどうかをより良く評価する方法である。</p>
<p>並び替え検定は、メタ回帰が未知の効果量を予測する際にどのように実行されるかを評価できる予備の「テスト」データセットを持っている必要はない。このため、特に、並べ替え検定は、メタ回帰モデルの頑健性を評価するために推奨されている <span class="citation">(<a href="references.html#ref-higgins2004controlling">JPT Higgins and Thompson 2004</a>)</span>。</p>
<p>メタ回帰モデルで並べ替え検定をどのように実行するかの詳細については、ここではあまり触れない。最も重要な部分は、元のデータ集合のすべての可能な並べ替え、またはランダムに選ばれた多くの並べ替えで得られた検定統計量に基づいて、私たちのモデルの <span class="math inline">\(p\)</span>-値を再計算することである。</p>
<p>ここで重要な指標は、並べ替えデータから得られる検定統計量が、元の検定統計量と<strong>等しいか大きいか</strong>、また<strong>その頻度</strong>である。例えば、並べ替えデータ 1000 個のうち 50 個で、検定統計量が元の検定統計量より大きいか等しいとすると、<span class="math inline">\(p\)</span> = 0.05となる。</p>
<p>メタ回帰モデルに対して並べ替え検定を行うには、<strong>{metafor}</strong> に内蔵されている <code>permutest</code> という関数を使用する。例として、以前適合した <code>m.qual.rep</code> モデルの結果を再計算してみよう。<code>permutest</code> 関数は <code>rma</code> オブジェクトと一緒に提供するだけである。並べ替え検定は、特に大きなデータセットの場合、計算量が多く実行に時間がかかる。</p>
<div class="sourceCode" id="cb241"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://wviechtb.github.io/metafor/reference/permutest.html">permutest</a></span><span class="op">(</span><span class="va">m.qual.rep</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Test of Moderators (coefficients 2:3):
## F(df1 = 2, df2 = 33) = 12.7844, p-val* = 0.0010
## 
## Model Results:
## 
##             estimate      se    tval   pval*    ci.lb   ci.ub 
## intrcpt       0.4964  0.1096  4.5316  0.2240   0.2736  0.7193      
## quality       0.0130  0.0152  0.8531  0.3640  -0.0179  0.0438      
## reputation    0.0350  0.0076  4.5964  0.0010   0.0195  0.0505  *** 
## 
## ---
## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre>
<p>すべての予測変数の結果を含むおなじみの出力が再び表示される。<code>pval*</code> 列を見ると、評判予測変数の <span class="math inline">\(p\)</span>-値が <span class="math inline">\(p\)</span> &lt; 0.001 から <span class="math inline">\(p_*\)</span> = 0.001 に減少していることがわかる。しかし、これはまだ非常に有意であり、予測変数の効果が頑健であることを示している。</p>
<p>メタ回帰モデルの結果を報告する前に、必ずこの並べ換え検定を用いることが推奨されている <span class="citation">(<a href="references.html#ref-higgins2004controlling">JPT Higgins and Thompson 2004</a>)</span>。</p>
<div class="boximportant">
<p>
<strong>データが小さい場合の Permutation 検定</strong>
</p>
<p>
モデルに含まれる研究数 <span class="math inline"><span class="math inline">\(K\)</span></span>
が少ない場合、従来から使われている統計的有意性の閾値 (つまり<span class="math inline"><span class="math inline">\(p\)</span></span> &lt; 0.05)
に到達できないことに注意。
</p>
<p>
メタ回帰モデルの場合、<code>permutest</code>
を用いた並べ替え検定は、<span class="math inline"><span class="math inline">\(K\)</span></span> &gt; 4
の場合のみ統計的有意に達することができる <span class="citation"><span class="citation">(<a href="references.html#ref-viechtbauer2015comparison">Viechtbauer et al. 2015</a>)</span></span> 。
</p>
</div>
<p><br></p>
</div>
<div id="multimodel-inference" class="section level4" number="8.3.3.5">
<h4>
<span class="header-section-number">8.3.3.5</span> マルチモデル推論<a class="anchor" aria-label="anchor" href="#multimodel-inference"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p>私たちはすでに、<strong>マルチ・モデル推論</strong>と呼ばれる方法で、予測変数の全ての可能な組み合わせをモデル化することができることを述べた。これは、どの予測変数の組み合わせが最良の適合を提供するか、そして、どの予測変数が全体として最も重要であるかを調査することができる。マルチモデル推論を行うには、 <code>multimodel.inference</code> 関数を使用する<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;このトピックに関する詳細な情報は、Wolfgang Viechtbauer が &lt;strong&gt;{metafor}&lt;/strong&gt; ドキュメントの一部として書いている &lt;a href="https://www.metafor-project.org/doku.php/tips:model_selection_with_glmulti_and_mumin"&gt;vignette&lt;/a&gt; は、情報が多いので参照されたい。&lt;/p&gt;'><sup>33</sup></a>。</p>
<div class="boxdmetar">
<p>
<strong>“multimodel.inference” 関数</strong>
</p>
<p>
<code>multimodel.inference</code> 関数は、<strong>{dmetar}</strong>
パッケージに含まれている。<strong>{dmetar}</strong>
がインストールされ、コンピュータに読み込まれると、この関数を使用できるようになる。もし、<strong>{dmetar}</strong>
をインストールして<strong>いない</strong>場合は、以下の手順でインストールできる。
</p>
<ol style="list-style-type: decimal">
<li>
関数のソースコードにアクセスする <a href="https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/power.analysis.subgroup.R">オンライン</a>.
</li>
<li>
ソースコード全体をコンソール (R Studio の左下ペイン)
にコピー＆ペーストし、Enterキーを押して、 <em>R</em>
に関数を「学習」させる。
</li>
<li>
<strong>{metafor}</strong>, <strong>{ggplot2}</strong>,
<strong>{MuMIn}</strong>
パッケージがインストールされ、ロードされていることを確認する。
</li>
</ol>
</div>
<p>この関数では、以下のパラメータを指定する必要がある。</p>
<ul>
<li><p><strong><code>TE</code></strong>. 各研究の効果量。データセットの効果量列の名前を引用符で囲んで指定する必要がある (例: <code>TE = "effectize"</code>)。</p></li>
<li><p><strong><code>seTE</code></strong>. 効果量の標準誤差。データセットの標準誤差列の名前を指定する必要があい (引用符で囲んで、例えば <code>seTE = "se"</code>)。</p></li>
<li><p><strong><code>data</code></strong>. 効果量、標準誤差、メタ回帰予測変数が含まれるデータフレーム。</p></li>
<li><p><strong><code>predictors</code></strong>. マルチモデル推論に使用する予測因子を指定する文字の連結配列。予測因子の名前は、<code>data</code> に与えられたデータフレームの列名と同じでなければならない。</p></li>
<li><p><strong><code>method</code></strong>. 効果量のプーリングに使用するメタ分析モデル。固定効果モデルには <code>"FE"</code> が用いられる。<code>"DL"</code>, <code>"SJ"</code>, <code>"ML"</code>, <code>"REML"</code> など、複数のランダム効果モデルが利用可能である。<code>"FE"</code> を使用する場合、Knapp-Hartung 法は固定効果モデルで使用することを意図していないため、<code>test</code> 引数は自動的に <code>"z"</code> に設定される。デフォルトは <code>"REML"</code> である。</p></li>
<li><p><strong><code>test</code></strong>. 検定統計量と信頼区間を計算する際に利用する手法。デフォルトは <code>"knha"</code> で、Knapp-Hartung 調整を利用する。コンベンショナルな Wald タイプの検定は、この引数を <code>"z"</code> に設定することで計算される。</p></li>
<li><p><strong><code>eval.criterion</code></strong>. 適合したモデルに適用する評価基準。<code>"AICc"</code> (デフォルト、 スモールサンプル補正した赤池情報量規準)、 <code>"AIC"</code> (赤池情報量規準)、または <code>"BIC"</code> (ベイズ情報量規準) のいずれかを指定することが可能である。</p></li>
<li><p><strong><code>interaction</code></strong>. <code>FALSE</code> (デフォルト) に設定すると、予測変数間の交互作用は考慮されていない。このパラメータを <code>TRUE</code> に設定すると、すべての交互作用がモデル化される。</p></li>
</ul>
<p>では、データセット <code>MVRegressionData</code> のすべての予測変数を使って、交互作用<strong>なしで</strong> マルチモデル推論を実行してみよう。<code>multimodel.inference</code> 関数を実行すると、特に予測変数の数が多い場合、時間がかかることに注意しておこう。</p>
<div class="sourceCode" id="cb243"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="http://dmetar.protectlab.org/reference/multimodel.inference.html">multimodel.inference</a></span><span class="op">(</span>TE <span class="op">=</span> <span class="st">"yi"</span>, </span>
<span>                     seTE <span class="op">=</span> <span class="st">"sei"</span>,</span>
<span>                     data <span class="op">=</span> <span class="va">MVRegressionData</span>,</span>
<span>                     predictors <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"pubyear"</span>, <span class="st">"quality"</span>, </span>
<span>                                    <span class="st">"reputation"</span>, <span class="st">"continent"</span><span class="op">)</span>,</span>
<span>                     interaction <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span></code></pre></div>
<pre><code>## Multimodel Inference: Final Results
## --------------------------
##  - Number of fitted models: 16
##  - Full formula: ~ pubyear + quality + reputation + continent
##  - Coefficient significance test: knha
##  - Interactions modeled: no
##  - Evaluation criterion: AICc 
## 
## 
## Best 5 Models
## --------------------------
## [...]
##    (Intrc) cntnn  pubyr   qulty   rpttn df logLik AICc delta weight
## 12       +     + 0.3533         0.02160  5  2.981  6.0  0.00  0.536
## 16       +     + 0.4028 0.02210 0.01754  6  4.071  6.8  0.72  0.375
## 8        +     + 0.4948 0.03574          5  0.646 10.7  4.67  0.052
## 11       +       0.2957         0.02725  4 -1.750 12.8  6.75  0.018
## 15       +       0.3547 0.02666 0.02296  5 -0.395 12.8  6.75  0.018
## Models ranked by AICc(x) 
## 
## 
## Multimodel Inference Coefficients
## --------------------------
##                          Estimate  Std. Error   z value  Pr(&gt;|z|)
## intrcpt                0.38614661 0.106983583 3.6094006 0.0003069
## continentNorth America 0.24743836 0.083113174 2.9771256 0.0029096
## pubyear                0.37816796 0.083045572 4.5537402 0.0000053
## reputation             0.01899347 0.007420427 2.5596198 0.0104787
## quality                0.01060060 0.014321158 0.7402055 0.4591753
## 
## 
## Predictor Importance
## --------------------------
##        model importance
## 1    pubyear  0.9988339
## 2  continent  0.9621839
## 3 reputation  0.9428750
## 4    quality  0.4432826</code></pre>
<p><span class="math display">\[~\]</span></p>
<div class="inline-figure"><img src="Doing_Meta_Analysis_in_R_files/figure-html/unnamed-chunk-206-1.png" width="70%" style="display: block; margin: auto;"></div>
<p></p>
<p>見どころ満載なので、順を追って出力を見ていこう。</p>
<ul>
<li><p><strong><code>Multimodel Inference: Final Results</code></strong>. この部分は、適合したモデルについての詳細な情報を提供する。 <span class="math inline">\(2^4 = 16\)</span> 可能なモデルの総数が適合したことがわかる。また、この関数はモデルの比較に補正済みAIC (<code>aicc</code>) を使用していることがわかる。</p></li>
<li><p><strong><code>Best 5 Models</code> </strong>. ここに表示されているのは、AICc が最も低い5つのモデルで、低いものから高いものへとソートされている。予測変数は表の列に、モデルは行に表示される。数字 (重み) または <code>+</code> 記号 (カテゴリ予測変数の場合) は、予測変数/交互作用項がモデルで用いられたことを示し、空のセルは、予測変数が省略されたことを示す。私たちは、 <code>TE ~ 1 + continent + pubyear + reputation</code> が最良の適合を示すことがわかる (AICc = 6.0)。しかし、他の予測変数の組み合わせは、この値に非常に近い。したがって、どのモデルが本当に「ベスト」モデルであるかを言うのは難しい。しかし、上位5つのモデルはすべて予測変数 <code>pubyear</code> を含んでおり、この変数が特に重要である可能性を示唆している。</p></li>
<li><p><strong><code>Multimodel Inference Coefficients</code></strong>. ここでは、すべての予測変数の係数を、それらが出現するすべてのモデルにわたって集約して見ることができる。係数推定値は、 <code>pubyear</code> ( <span class="math inline">\(\hat\beta\)</span> = 0.378)で最も大きく、これは以前の発見を裏付ける。近似信頼区間は、<code>Std.Error</code> に格納された値に 1.96 を掛けたものを、<code>Estimate</code> と引き算したり足したりすることで得ることができる。</p></li>
<li><p><strong>モデル平均予測変数の重要度プロット</strong>. このプロットでは、すべてのモデルで各予測変数の平均された重要度が表示される。再び、<code>pubyear</code> が最も重要な予測変数であることがわかる。次に、<code>reputation</code>、<code>continent</code>、<code>quality</code> が続く。</p></li>
</ul>
<div class="boxinfo">
<p>
<strong>マルチモデル推論の限界</strong>
</p>
<p>
この例から、マルチモデル推論が、効果量の違いを予測するためにどの予測変数が重要であるかを包括的に把握するのに有効な方法であることが明らかになるはずである。
</p>
<p>
ステップ・ワイズ回帰法の問題のいくつかを回避しているとはいえ、この方法はまだ<strong>探索的</strong>と見なされるべきで、予測変数が分析する研究分野の効果量とどのように関連しているかについて予備知識がない場合に使用することができることに注意。
</p>
<p>
マルチモデル推論の結果に基づいてメタ回帰モデルを構築することにした場合、これを報告することが極めて重要である。なぜなら、そのようなモデルは
<strong>a priori</strong>
な仮説に基づくものではなく、このサンプルにおける統計的特性に基づいて構築されたためである。
</p>
</div>
<p><span class="math display">\[\tag*{$\blacksquare$}\]</span></p>
<p><br></p>
</div>
</div>
</div>
<div id="演習問題-7" class="section level2" number="8.4">
<h2>
<span class="header-section-number">8.4</span> 演習問題<a class="anchor" aria-label="anchor" href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C-7"><i class="fas fa-link"></i></a>
</h2>
<div class="boxinfo">
<p>
<strong>知識を試そう！</strong>
</p>
<ol style="list-style-type: decimal">
<li>
一次研究で用いられる従来の回帰分析と、メタ回帰の違いは何か？
</li>
</ol>
<ol start="2" style="list-style-type: decimal">
<li>
サブグループ解析とメタ回帰は密接な関係がある。メタ回帰の公式をどのようにサブグループデータに適応させることができるか？
</li>
</ol>
<ol start="3" style="list-style-type: decimal">
<li>
メタ回帰において、個々の研究に異なる重みを与えるためにどのような方法が用いられるか？
</li>
</ol>
<ol start="4" style="list-style-type: decimal">
<li>
データによく適合するメタ回帰モデルにはどのような特徴があるか？これを調べるには、どのような指標を用いればよいか？
</li>
</ol>
<ol start="5" style="list-style-type: decimal">
<li>
メタ分析の手法でサブグループ分析を計算する場合、<span class="math inline"><span class="math inline">\(\tau^2\)</span></span>
の値をサブグループで別々にするか、共通にするか？
</li>
</ol>
<ol start="6" style="list-style-type: decimal">
<li>
(多重) メタ回帰の限界と落とし穴は何か？
</li>
</ol>
<ol start="7" style="list-style-type: decimal">
<li>
(複数の)
メタ回帰モデルの頑健性を向上させるために利用できる方法を2つ挙げ、それが有用である理由を述べよ。
</li>
</ol>
<p>
<strong>問題の解答は、本書の巻末 <a href="https://bookdown.org/baba_yoshihiko/Doing_Meta_Analysis_in_R/qanda.html#qanda8">Appendix
A</a> にある。</strong>
</p>
</div>
<p><br></p>
</div>
<div id="要約-4" class="section level2" number="8.5">
<h2>
<span class="header-section-number">8.5</span> 要約<a class="anchor" aria-label="anchor" href="#%E8%A6%81%E7%B4%84-4"><i class="fas fa-link"></i></a>
</h2>
<ul>
<li><p>メタ回帰では、従来の回帰手法を研究レベルのデータに適応させる。サブグループ分析は、カテゴリカル予測因子と共通の推定値 <span class="math inline">\(\tau^2\)</span> を持つメタ回帰の特別なケースと見なすことができる。</p></li>
<li><p>メタ回帰モデルの目的は、データにおける真の効果量の違い (すなわち、研究間異質性分散 <span class="math inline">\(\tau^2\)</span> ) を<strong>説明</strong>することである。モデルがデータによく合っている場合、回帰直線からの真の効果の偏差は、プール効果からの最初の偏差よりも小さくなるはずである。この場合、説明できない異質性、つまり残差は小さくなる。これは、<span class="math inline">\(R^2_*\)</span> 指数によって捕捉され、モデルによって説明される異質性の変動のパーセンテージを知らせる。</p></li>
<li><p><strong>多重メタ回帰</strong>では、2つ以上の予測変数が同じメタ回帰モデルで使用される。また、交互作用項を導入することで、ある変数の予測値が他の変数の異なる値に対して変化するかどうかを検定することも可能である。</p></li>
<li><p>多重メタ回帰は非常に汎用性の高い手法であるが、限界がある。多重メタ回帰は、真の関係ではなくランダムなノイズがモデル化されることを意味する、<strong>オーバーフィット</strong>モデルを非常に容易にする。予測変数の多重共線性は、私たちのモデルの妥当性に脅威を与えるだろう。</p></li>
<li><p>メタ回帰モデルが頑健であることを保証するために、いくつかのアプローチがある。例えば、<strong>定義された</strong>理論的根拠に基づいてのみモデルを適合させたり、並べ替え検定を使用したりすることができる。マルチモデル推論は、探索的アプローチとして使用することができる。この方法は、潜在的に重要な予測因子を指摘することができ、将来の研究で検証すべき仮説を導き出すために使用することができる。</p></li>
</ul>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="subgroup.html"><span class="header-section-number">7</span> サブグループ解析</a></div>
<div class="next"><a href="pub-bias.html"><span class="header-section-number">9</span> 出版バイアス</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#metareg"><span class="header-section-number">8</span> メタ回帰</a></li>
<li>
<a class="nav-link" href="#the-metareg-model"><span class="header-section-number">8.1</span> メタ回帰モデル</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E3%82%AB%E3%83%86%E3%82%B4%E3%83%AA%E3%82%AB%E3%83%AB%E4%BA%88%E6%B8%AC%E5%A4%89%E6%95%B0%E3%81%AE%E3%83%A1%E3%82%BF%E5%9B%9E%E5%B8%B0"><span class="header-section-number">8.1.1</span> カテゴリカル予測変数のメタ回帰</a></li>
<li><a class="nav-link" href="#metareg-continuous"><span class="header-section-number">8.1.2</span> 連続予測因子によるメタ回帰</a></li>
<li><a class="nav-link" href="#metareg-model-fit"><span class="header-section-number">8.1.3</span> モデルの適合性を評価</a></li>
</ul>
</li>
<li><a class="nav-link" href="#metareg-R"><span class="header-section-number">8.2</span> R のメタ回帰について</a></li>
<li>
<a class="nav-link" href="#multiple-metareg"><span class="header-section-number">8.3</span> 多重メタ回帰</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#interact"><span class="header-section-number">8.3.1</span> 交互作用</a></li>
<li><a class="nav-link" href="#limits-metareg"><span class="header-section-number">8.3.2</span> 多重メタ回帰にありがちな落とし穴</a></li>
<li><a class="nav-link" href="#multiple-metareg-R"><span class="header-section-number">8.3.3</span> R の多重メタ回帰</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C-7"><span class="header-section-number">8.4</span> 演習問題</a></li>
<li><a class="nav-link" href="#%E8%A6%81%E7%B4%84-4"><span class="header-section-number">8.5</span> 要約</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Doing Meta-Analysis in R</strong>: A Hands-on Guide" was written by Mathias Harrer, Pim Cuijpers, Toshi A. Furukawa, David D. Ebert. </p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
