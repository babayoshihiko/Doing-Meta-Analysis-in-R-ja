<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>11 構造方程式モデリングメタ分析 | Doing Meta-Analysis in R</title>
<meta name="author" content="Mathias Harrer">
<meta name="author" content="Pim Cuijpers">
<meta name="author" content="Toshi A. Furukawa">
<meta name="author" content="David D. Ebert">
<meta name="description" content="前 章で、メタ分析モデルにはマルチレベル構造が内在していることを示した。この性質を利用して、例えば、従来のメタ分析を３レベルモデルに拡張することができる。  統計的手法に関しては、よく別々の箱に入れられることがあるが、これは非常におかしなことである。研究や実務では、統計のそれぞれの手法は無関係なものとして扱われることが多いが、実際はそうではない。例えば、分散分析 (ANOVA)...">
<meta name="generator" content="bookdown 0.36 with bs4_book()">
<meta property="og:title" content="11 構造方程式モデリングメタ分析 | Doing Meta-Analysis in R">
<meta property="og:type" content="book">
<meta property="og:description" content="前 章で、メタ分析モデルにはマルチレベル構造が内在していることを示した。この性質を利用して、例えば、従来のメタ分析を３レベルモデルに拡張することができる。  統計的手法に関しては、よく別々の箱に入れられることがあるが、これは非常におかしなことである。研究や実務では、統計のそれぞれの手法は無関係なものとして扱われることが多いが、実際はそうではない。例えば、分散分析 (ANOVA)...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="11 構造方程式モデリングメタ分析 | Doing Meta-Analysis in R">
<meta name="twitter:site" content="@MathiasHarrer">
<meta name="twitter:description" content="前 章で、メタ分析モデルにはマルチレベル構造が内在していることを示した。この性質を利用して、例えば、従来のメタ分析を３レベルモデルに拡張することができる。  統計的手法に関しては、よく別々の箱に入れられることがあるが、これは非常におかしなことである。研究や実務では、統計のそれぞれの手法は無関係なものとして扱われることが多いが、実際はそうではない。例えば、分散分析 (ANOVA)...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Fira_Sans-0.4.7/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.7/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.5.1/transition.js"></script><script src="libs/bs3compat-0.5.1/tabs.js"></script><script src="libs/bs3compat-0.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
<style>

    :root {
      --background-color: #FFFEFA;
      --text-color: #000;
      --highlight-color: #277DB0;
      --border-color: #999896;
      --grey-color: #6C6C6C;
      --line-color: #eee;
      --bg-box: #f5f5f5;
      --box-border-color: #eeeeee;
      --code-bg: #f8f8f8;
      --code-chunk-bg: linear-gradient(160deg,#f8f8f8 0, #f1f1f1 100%);
      --code-text-color: #212529;
      --hr-border-top: 1px solid rgba(0,0,0,0.1);
      --table-text-color: #000;
      --toc-active: #eee;
      --form-color: #4D4C4B;
      --form-background-color: #FFFEFA;
      --form-border: 1px solid #999896;
      --aa-cursor-background-color: #B2D7FF;
    }


    [data-theme="dark"] {
      --background-color: #2b2b2b;
      --text-color: #ffffff;
      --highlight-color: #34a8ed;
      --border-color: yellow;
      --grey-color: #cfcfcf;
      --line-color: #575757;
      --bg-box: #474747;
      --box-border-color: #474747;
      --code-bg: #474747;
      --code-chunk-bg: linear-gradient(160deg,#CDCDCD 0,#f1f1f1 100%);
      --code-text-color: #ffffff;
      --hr-border-top: 1px solid #575757;
      --table-text-color: #ffffff;
      --toc-active: #474747;
      --form-color: #cfcfcf;
      --form-background-color: #474747;
      --form-border: 1px solid #575757;
      --aa-cursor-background-color: #2b2b2b;
    }

    .algolia-autocomplete .aa-dropdown-menu .aa-suggestion {
      color: var(--form-color);
      border-bottom: 1px var(--form-border) solid;
      background-color: var(--form-background-color);
    }

    .algolia-autocomplete .aa-dropdown-menu .aa-suggestion.aa-cursor {
      background-color: var(--aa-cursor-background-color);
    }

    strong {
      font-family: "Helvetica Neue",
        Arial,
        "Hiragino Kaku Gothic ProN",
        "Hiragino Sans",
        Meiryo,
        sans-serif;
      font-weight: bolder;
    }

    .form-control {
      color: var(--form-color);
      background-color: var(--form-background-color);
      border: var(--form-border);
    }

    .form-control:focus {
      color: var(--text-color);
      background-color: var(--form-background-color);
      border: var(--form-border);
    }


    nav[data-toggle="toc"] .nav a.nav-link.active, nav[data-toggle="toc"] .nav .nav-link.active > li > a {
        background-color: var(--toc-active);
    }

    .btn-circle.btn-md {
      width: 50px;
      height: 50px;
      padding: 7px 10px;
      border-radius: 25px;
      font-size: 10px;
      text-align: center;
    }


    .lightable-classic td {
      color: var(--text-color);
    }


    .table {
      color: var(--table-text-color);
    }

    hr {
      border-top: var(--hr-border-top);
    }

    code {
      background-color: var(--code-bg);
      color: var(--code-text-color);
    }

    pre {
      background-image: var(--code-chunk-bg);
    }

    body {
      background-color: var(--background-color);
      color: var(--text-color);
    }

    a {
      color: var(--highlight-color);
    }

    .header-section-number {
      color: var(--grey-color);
    }

    small.text-muted {
      color: var(--grey-color) !important;
    }


    .firstcharacter {
      color: var(--highlight-color);
    }

    p.caption {
      color: var(--grey-color);
    }

    .figure {
      border-top: 2px solid var(--line-color);
      border-bottom: 2px solid var(--line-color);
    }


    .inline-figure {
      border: 0;
      box-shadow: none;
    }

    .boxinfo {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxinfo:before {
        content: '\f0eb';
        font-family: FontAwesome;
        left:20px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxempty {
      padding: 1em 1em 1em 1.1em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxempty:before {
        content: '\f0eb';
        font-family: FontAwesome;
        left:0px;
        position:absolute;
        font-size: 30px;
        color: transparent;
     }

    .boximportant {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boximportant:before {
        content: '\f06a';
        font-family: FontAwesome;
        left:13px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxreport {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxreport:before {
        content: '\f570';
        font-family: FontAwesome;
        left:15px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxdmetar {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .csl-entry {
      margin-bottom: 20px;
      padding-left: 1.5em;
      text-indent:-1.5em;
    }

    .boxdmetar:before {
        content: '\f4f7';
        font-family: FontAwesome;
        left:10px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .boxquestion {
      padding: 1em 1em 1em 3em;
      margin-bottom: 10px;
      background: var(--bg-box);
      position:relative;
      border-width: 3px;
      border-style: solid;
      border-color: var(--box-border-color);
      border-radius: .25rem;
    }

    .boxquestion:before {
        content: '\f059';
        font-family: FontAwesome;
        left:12px;
        position:absolute;
        font-size: 30px;
        color: var(--highlight-color);
     }

    .mode-switch {
      font-size: 0.9rem;
    }

    img {
      max-width: 100%;
      height: auto;
      border-radius: .25rem;
    }


    .firstcharacter {
      color: var(--highlight-color);
      float: left;
      font-size: 40px;
      line-height: 50px;
      padding-bottom: 2px;
      padding-right: 8px;
      padding-left: 2px;
    }


    .btn-circle.btn-sm {
        width: 30px;
        height: 30px;
        padding: 6px 0px;
        border-radius: 15px;
        font-size: 20px;
        text-align: center;
    }
    .btn-circle.btn-md {
        width: 50px;
        height: 50px;
        padding: 7px 10px;
        border-radius: 25px;
        font-size: 20px;
        text-align: center;
    }
    .btn-circle.btn-xl {
        width: 60px;
        height: 60px;
        padding: 7px 7px;
        border-radius: 35px;
        font-size: 30px;
        text-align: center;
    }

    #critical-btn.btn-secondary {
      background-color: var(--grey-color);
      border-color: var(--grey-color);
    }

    .sticky-item {
        position: fixed;
        bottom: 30px;
        right: 30px;
    }



    </style>
<link rel="shortcut icon" href="favicon.ico">
<script type="text/x-mathjax-config">
    const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
    for (let popover of popovers){
      const div = document.createElement('div');
      div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
      div.innerHTML = popover.getAttribute('data-content');

      // Will this work with TeX on its own line?
      var has_math = div.querySelector("span.math");
      if (has_math) {
        document.body.appendChild(div);
      	MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
      	MathJax.Hub.Queue(function(){
          popover.setAttribute('data-content', div.innerHTML);
      	})
      }
    }
    </script><link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script><script type="text/javascript">
      // Add switch element
      document.addEventListener('DOMContentLoaded', function(event){
        let darkSwitch = document.createElement('div');
        darkSwitch.innerHTML = "<div class='sticky-item'><button type='button' id='critical-btn' class='btn btn-dark btn-circle btn-xl'>🌓</button></div>"
        document.body.appendChild(darkSwitch);
      })

    $(document).ready(function() {

        $("#critical-btn").click(function () {

            if ($(this).hasClass('btn-dark')){
                $('#critical-btn').removeClass('btn-dark').addClass('btn-secondary');
                $(this).addClass('btn-secondary').removeClass('btn-dark');
            }

            else if ($(this).hasClass('btn-secondary')){
                $('#critical-btn').removeClass('btn-secondary').addClass('btn-dark');
                $(this).addClass('btn-dark').removeClass('btn-secondary');
            }

        })
    })
    </script><script type="text/javascript">
      // Wait for document to load
      document.addEventListener("DOMContentLoaded", function(event) {
        document.documentElement.setAttribute("data-theme", "light");

        // Get our button switcher
        var themeSwitcher = document.getElementById("critical-btn");

        // When our button gets clicked
        themeSwitcher.onclick = function() {
          // Get the current selected theme, on the first run
          // it should be `light`
          var currentTheme = document.documentElement.getAttribute("data-theme");

          // Switch between `dark` and `light`
          var switchToTheme = currentTheme === "dark" ? "light" : "dark"

          // Set our currenet theme to the new one
          document.documentElement.setAttribute("data-theme", switchToTheme);

          // Save current selection
          localStorage.setItem('themeMode', switchToTheme);

        }
      });

      // keep selection across pages
      document.addEventListener('DOMContentLoaded', function(event){
        const currentTheme = localStorage.getItem('themeMode')
        if (currentTheme === 'dark'){
        document.documentElement.setAttribute("data-theme", 'dark');
          if ($("#critical-btn").hasClass('btn-dark')) {
            $('#critical-btn').removeClass('btn-dark').addClass('btn-secondary');
            $('#critical-btn').addClass('btn-secondary').removeClass('btn-dark');
          }
        } else {
        document.documentElement.setAttribute("data-theme", 'light');
          if ($("#critical-btn").hasClass('btn-secondary')) {
            $('#critical-btn').removeClass('btn-secondary').addClass('btn-dark');
            $('#critical-btn').addClass('btn-dark').removeClass('btn-secondary');
          }
      }})
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><style type="text/css">
    
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  </style>
<style type="text/css">
    /* Used with Pandoc 2.11+ new --citeproc when CSL is used */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
        }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="A Hands-on Guide">Doing Meta-Analysis in R</a>:
        <small class="text-muted">A Hands-on Guide</small>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">ようこそ！</a></li>
<li><a class="" href="preface.html">序章</a></li>
<li><a class="" href="about-the-authors.html">著者について</a></li>
<li class="book-part">はじめに</li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> はじめに</a></li>
<li><a class="" href="discovering-R.html"><span class="header-section-number">2</span> R の発見</a></li>
<li class="book-part">Rでメタ分析</li>
<li><a class="" href="effects.html"><span class="header-section-number">3</span> 効果量</a></li>
<li><a class="" href="pooling-es.html"><span class="header-section-number">4</span> 効果量のプール</a></li>
<li><a class="" href="heterogeneity.html"><span class="header-section-number">5</span> 研究間異質性</a></li>
<li><a class="" href="forest.html"><span class="header-section-number">6</span> フォレストプロット</a></li>
<li><a class="" href="subgroup.html"><span class="header-section-number">7</span> サブグループ解析</a></li>
<li><a class="" href="metareg.html"><span class="header-section-number">8</span> メタ回帰</a></li>
<li><a class="" href="pub-bias.html"><span class="header-section-number">9</span> 出版バイアス</a></li>
<li class="book-part">高度な分析</li>
<li><a class="" href="multilevel-ma.html"><span class="header-section-number">10</span> 「マルチレベル」メタ分析</a></li>
<li><a class="active" href="sem.html"><span class="header-section-number">11</span> 構造方程式モデリングメタ分析</a></li>
<li><a class="" href="netwma.html"><span class="header-section-number">12</span> ネットワークメタ分析</a></li>
<li><a class="" href="bayesian-ma.html"><span class="header-section-number">13</span> ベイズメタ分析</a></li>
<li class="book-part">各種ツール</li>
<li><a class="" href="power.html"><span class="header-section-number">14</span> 検出力分析</a></li>
<li><a class="" href="risk-of-bias-plots.html"><span class="header-section-number">15</span> バイアスリスクのプロット</a></li>
<li><a class="" href="reporting-reproducibility.html"><span class="header-section-number">16</span> 報告と再現性</a></li>
<li><a class="" href="es-calc.html"><span class="header-section-number">17</span> 効果量の計算と換算</a></li>
<li class="book-part">付録</li>
<li><a class="" href="qanda.html"><span class="header-section-number">A</span> Q&amp;A</a></li>
<li><a class="" href="formula.html"><span class="header-section-number">B</span> 効果量の計算式</a></li>
<li><a class="" href="symbollist.html"><span class="header-section-number">C</span> シンボルマーク一覧</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">D</span> R およびパッケージ情報</a></li>
<li><a class="" href="corrections.html"><span class="header-section-number">E</span> 訂正・備考</a></li>
<li><a class="" href="%E6%9C%AC%E6%9B%B8%E3%81%AE%E5%BC%95%E7%94%A8.html">本書の引用</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="sem" class="section level1" number="11">
<h1>
<span class="header-section-number">11</span> 構造方程式モデリングメタ分析<a class="anchor" aria-label="anchor" href="#sem"><i class="fas fa-link"></i></a>
</h1>
<hr>
<div class="inline-figure"><img src="_figs/semtitle_leaf.jpg"></div>
<p><br></p>
<p><span class="firstcharacter">前</span>
章で、メタ分析モデルにはマルチレベル構造が内在していることを示した。この性質を利用して、例えば、従来のメタ分析を３レベルモデルに拡張することができる。</p>
<p>
</p>
<p>統計的手法に関しては、よく別々の箱に入れられることがあるが、これは非常におかしなことである。研究や実務では、統計のそれぞれの手法は無関係なものとして扱われることが多いが、実際はそうではない。例えば、<strong>分散分析</strong> (ANOVA) とカテゴリ予測変数の線形回帰は本質的に同じことを行なっていると教えると、多くの社会科学の学生はたいてい驚く<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;ANOVA は &lt;span class="math inline"&gt;\(y_{ij} = \mu + \tau_i + \epsilon_{ij}\)&lt;/span&gt; モデルに基づいている、ここで &lt;span class="math inline"&gt;\(\tau_i\)&lt;/span&gt; は &lt;span class="math inline"&gt;\(i\)&lt;/span&gt; th要因レベル/治療の効果、そして &lt;span class="math inline"&gt;\(\epsilon_{ij}\)&lt;/span&gt; は (説明できない) ランダムエラーによる偏差を示している &lt;span class="citation"&gt;(&lt;a href="references.html#ref-montgomery"&gt;Montgomery 2013, chap. 3.2&lt;/a&gt;)&lt;/span&gt;。これは線形回帰モデルの特殊なケースにほかならない。主な違いは、&lt;span class="math inline"&gt;\(\tau_i\)&lt;/span&gt; が &lt;strong&gt;effect-coded&lt;/strong&gt; であることである (たとえば、治療変数が-1 と1のいずれかであり、カテゴリ治療効果の合計が0になる: &lt;span class="math inline"&gt;\(\sum_{i={1}^{a} \tau_i = 0\)&lt;/span&gt; )。一方、線形回帰モデルでは、カテゴリカル予測変数は通常ダミー・コード化 (たとえば、0と1) される&lt;/p&gt;'><sup>58</sup></a>。2つの方法が異なる文脈で使われ、別個のものとして教えられてきたときに、このようになることがある。</p>
<p></p>
<p>この例と同じように、マルチレベルモデルを<strong>構造方程式モデル</strong> (Structural Equation Model, SEM) の特殊な形態として捉え始めたのはごく最近のことである <span class="citation">(<a href="references.html#ref-mehta2005people">Mehta and Neale 2005</a>; <a href="references.html#ref-bauer2003estimating">Bauer 2003</a>)</span> 。すでに学んだように、すべてのメタ分析はマルチレベルモデルに基づいている。結果として、プール効果量が潜在 (または未観測) 変数として扱われる構造方程式モデルとしてメタ分析を扱うことが可能である <span class="citation">(<a href="references.html#ref-cheung2015meta">Cheung 2015a, chap. 4.6</a>)</span>。要するに、メタ分析はマルチレベルモデルなので、構造方程式モデルとしても表現できるのである。</p>
<p>
</p>
<p>これは、これまで取り上げられてきた種類のメタ分析を構造方程式モデリングの観点から概念化できることを意味するだけではない。SEM を使って、より複雑なメタ分析モデルを構築することもできるようになるのである。<strong>メタ分析的</strong>な SEM を用いて、<strong>因子分析的</strong>なモデルを検証したり、アウトカムを複数含む<strong>多変量メタ分析</strong>を実行することが可能である (これらは、応用例の一部に過ぎない)。</p>
<p>メタ分析 SEM は、利用可能なすべてのエビデンスを考慮した上で、文献中のあるモデルが実際に成り立っているかどうかを評価したい場合に役立つ。逆に、ある理論がエビデンスに裏付けられていないかどうか、あるいはさらに興味深いことに、その理論がサブグループにしか適用されないかどうかをチェックするためにも使用することが可能である。</p>
<p>メタ分析的な SEM の手法を適用するには、もちろん構造方程式モデリングに基本的に慣れていることが前提になる。そこで次のセクションでは、構造方程式モデリングの背後にある一般的な考え方と、そのメタ分析的な拡張について簡単に説明する。</p>
<p><br></p>
<div id="what-is-meta-sem" class="section level2" number="11.1">
<h2>
<span class="header-section-number">11.1</span> メタ分析構造方程式モデリングとは？<a class="anchor" aria-label="anchor" href="#what-is-meta-sem"><i class="fas fa-link"></i></a>
</h2>
<hr>
<p>構造方程式モデリングは、<strong>顕在</strong> (観測) 変数と<strong>潜在</strong>変数の関係に関する仮説を検定するために用いられる統計手法である <span class="citation">(<a href="references.html#ref-kline2015principles">Kline 2015, chap. 1</a>)</span>。潜在変数は、観測されないか、<strong>観測可能</strong>のどちらかである。例えば、パーソナリティは、例えば、アンケートの様々な項目を通して間接的にしか測定できない構成要素である。SEM では、顕在変数と潜在変数の間の仮定された関係 (「構造」) が、測定された顕在変数を用いて、その測定誤差を考慮しながらモデル化される。</p>
<p>SEM 分析は、「従来の」統計的仮説検定 (例えば、<span class="math inline">\(t\)</span>-検定など) とは多少違う点がある。通常、統計的検定は、<span class="math inline">\(H_0: \mu_1 = \mu_2\)</span> (ここで、<span class="math inline">\(\mu_1\)</span> と <span class="math inline">\(\mu_2\)</span> は2つのグループの平均) のような<strong>帰無仮説</strong>に対する検定を伴う。このような検定では、研究者は、帰無仮説を<strong>棄却</strong>することを「目的」とし、これによって、2つのグループが異なると結論づけることができることがある。しかし、SEM では、特定の構造モデルが事前に提案され、適合度が十分であれば、このモデルを<strong>受け入れる</strong>ことを「目的」とする <span class="citation">(<a href="references.html#ref-cheung2015meta">Cheung 2015a, chap. 2.4.6</a>)</span>。</p>
<p><br></p>
<div id="モデル仕様" class="section level3" number="11.1.1">
<h3>
<span class="header-section-number">11.1.1</span> モデル仕様<a class="anchor" aria-label="anchor" href="#%E3%83%A2%E3%83%87%E3%83%AB%E4%BB%95%E6%A7%98"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>一般に、SEM は一連の<strong>行列</strong>によって指定され、数学的に表現される。行列は、 <em>R</em> の <code>data.frame</code> オブジェクトのように、行と列を含む単純な表と考えることができる (実際、ほとんどのデータフレームは、<code>as.matrix</code> 関数を用いて簡単に行列に変換することが可能)。視覚的には、SEM は<strong>パス図</strong>として表現することができる。このようなパス図は、通常、非常に直感的であり、その解釈も簡単である。したがって、まず最初に SEM を<strong>視覚的に</strong>示し、その後、行列表記に移行しよう。</p>
<p><br></p>
<div id="パス図" class="section level4" number="11.1.1.1">
<h4>
<span class="header-section-number">11.1.1.1</span> パス図<a class="anchor" aria-label="anchor" href="#%E3%83%91%E3%82%B9%E5%9B%B3"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p></p>
<p>パス図は、SEM をグラフィカルに表現したものである。パス図の描き方について完全なコンセンサスは得られていないが、いくつかの規約がある。ここでは、パス図の主な構成要素と、それらが表現するものを紹介した。</p>
<div class="inline-table"><table class="table table-condensed table-striped" style="margin-left: auto; margin-right: auto;">
<thead><tr>
<th style="text-align:left;">
Symbol
</th>
<th style="text-align:left;">
Name
</th>
<th style="text-align:left;">
Description
</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:left;">
<span class="math inline">\(\square\)</span>
</td>
<td style="text-align:left;">
長方形
</td>
<td style="text-align:left;width: 13cm; ">
観測変数。
</td>
</tr>
<tr>
<td style="text-align:left;">
<span class="math inline">\(\circ\)</span>
</td>
<td style="text-align:left;">
円
</td>
<td style="text-align:left;width: 13cm; ">
潜在 (非観測) 変数
</td>
</tr>
<tr>
<td style="text-align:left;">
<span class="math inline">\(\triangle\)</span>
</td>
<td style="text-align:left;">
三角形
</td>
<td style="text-align:left;width: 13cm; ">
切片 (fixed vector of 1s).
</td>
</tr>
<tr>
<td style="text-align:left;">
<span class="math inline">\(\rightarrow\)</span>
</td>
<td style="text-align:left;">
矢印
</td>
<td style="text-align:left;width: 13cm; ">
予測。矢印の末端の変数が、先端の変数を予測する。Predictor <span class="math inline">\(\rightarrow\)</span> Target。
</td>
</tr>
<tr>
<td style="text-align:left;">
<span class="math inline">\(\leftrightarrow\)</span>
</td>
<td style="text-align:left;">
二重矢印
</td>
<td style="text-align:left;width: 13cm; ">
(共) 変量。双方向の矢印が2つの変数 (長方形/円) を結ぶ場合、2つの変数間の共分散・相関を意味する。双方向矢印が1つの変数の上にループを形成している場合、その変数の分散を意味する。
</td>
</tr>
</tbody>
</table></div>
<p>例として、単純な線形 (「非メタ分析」) 回帰モデルのパス図を作成してみよう。このモデルでは、<span class="math inline">\(y\)</span> を <span class="math inline">\(x\)</span> で予測したい。モデル式は次のようなものである。</p>
<p><span class="math display" id="eq:sem1">\[\begin{equation}
y_i = \beta_0 + \beta_1x_i + e_i
\tag{11.1}
\end{equation}\]</span></p>
<p>さて、この数式を「分解」してみよう。このモデルにおいて、<span class="math inline">\(x_i\)</span> と <span class="math inline">\(y_i\)</span> は観測された変数である。観測されない (潜在) 変数はない。<span class="math inline">\(y\)</span> の真の母平均は回帰切片 <span class="math inline">\(\beta_0\)</span> であり、<span class="math inline">\(\mu_x\)</span> は <span class="math inline">\(x\)</span> の母平均を示す。観測された予測変数の分散 <span class="math inline">\(x\)</span> は <span class="math inline">\(\sigma^2_x\)</span> で示される。 <span class="math inline">\(x\)</span> が <span class="math inline">\(y\)</span> の完全な予測因子でない場合、<span class="math inline">\(y\)</span> に関連する残留誤差分散 <span class="math inline">\(\sigma^2_{e_y}\)</span> がある程度存在することになる。以下の通り、2つの回帰係数がある。<span class="math inline">\(\beta_0\)</span> は切片で、<span class="math inline">\(\beta_1\)</span> は <span class="math inline">\(x\)</span> の傾きである。</p>
<p>これらの構成要素を用いて、線形回帰モデルのパス図を作成すると、以下のようになる。</p>
<div class="inline-figure"><img src="images/regression_path_sep.png" width="43%" style="display: block; margin: auto;"></div>
<p>また、このグラフモデルを出発点として、回帰モデルの式を組み立て直すことができる。このモデルから、<span class="math inline">\(y\)</span> は、<span class="math inline">\(x \times \beta_1\)</span> と <span class="math inline">\(1 \times \beta_0\)</span> という二つの要素に影響されていることが推測できる。 この二つの要素を足し合わせると、再び先ほどの <span class="math inline">\(y\)</span> の式にたどり着く。</p>
<p><br></p>
</div>
<div id="行列表現" class="section level4" number="11.1.1.2">
<h4>
<span class="header-section-number">11.1.1.2</span> 行列表現<a class="anchor" aria-label="anchor" href="#%E8%A1%8C%E5%88%97%E8%A1%A8%E7%8F%BE"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p>SEM を行列で表現する方法はいくつかある <span class="citation">(<a href="references.html#ref-joreskog2006lisrel">Jöreskog and Sörbom 2006</a>; <a href="references.html#ref-muthen2012mplus">Muthén and Muthén 2012</a>; <a href="references.html#ref-mcardle1984some">McArdle and McDonald 1984</a>)</span>。ここでは、<strong>Reticular Action Model</strong> (RAM) の定式化に焦点を当てることにする <span class="citation">(<a href="references.html#ref-mcardle1984some">McArdle and McDonald 1984</a>)</span>。なぜなら、この後に紹介する <strong>{metaSEM}</strong> パッケージでは、この式が使用されているからである。RAM は4つ行列を使用する。<span class="math inline">\(\boldsymbol{F}\)</span>、<span class="math inline">\(\boldsymbol{A}\)</span>、<span class="math inline">\(\boldsymbol{S}\)</span>、<span class="math inline">\(\boldsymbol{M}\)</span> という4つ行列を使用する。 <span class="math inline">\(\boldsymbol{M}\)</span> 行列は、今回取り上げるメタ分析的SEMに適合させる必要はないので、ここでは省略した<span class="citation">(より広範な紹介は <a href="references.html#ref-cheung2015meta">Cheung 2015a</a> を参照)</span>。</p>
<p>先ほどの線形回帰モデルに、残りの <span class="math inline">\(\boldsymbol{A}\)</span> , <span class="math inline">\(\boldsymbol{F}\)</span> , <span class="math inline">\(\boldsymbol{S}\)</span> 行列を指定する。この3つ行列は、すべて同じ行と列数で、モデルで持っている変数 <span class="math inline">\(x\)</span> と <span class="math inline">\(y\)</span> に対応している。したがって、回帰モデルの一般的な行列構造は、常に次のようになる。</p>
<div class="inline-figure"><img src="images/M1.png" width="18%" style="display: block; margin: auto;"></div>
<p><br></p>
<p><strong><span class="math inline">\(\boldsymbol{A}\)</span> 行列: 一方向矢印</strong></p>
<p><span class="math inline">\(\boldsymbol{A}\)</span> 行列は、パス・モデル中の非対称 (単一方向) 矢印を表す。この行列は、矢印が始まる変数の<strong>列</strong>のエントリを検索し ( <span class="math inline">\(x\)</span> )、次に矢印が終わる変数行列の<strong>行</strong>のエントリを検索することによって埋めることが可能である ( <span class="math inline">\(y\)</span> )。矢印の値 <span class="math inline">\(\beta_1\)</span> は、選択された列と行が行列の中で交差する場所に置かれる ( <span class="math inline">\(i_{y,x}\)</span> )。このモデルには、変数間の他のパスがないので、残りのフィールドを0で埋める。したがって、例の <span class="math inline">\(\boldsymbol{A}\)</span> 行列は次のようになる。</p>
<div class="inline-figure"><img src="images/M2.png" width="20%" style="display: block; margin: auto;"></div>
<p><br></p>
<p><strong><span class="math inline">\(\boldsymbol{S}\)</span> 行列: 一方向矢印</strong></p>
<p><span class="math inline">\(\boldsymbol{S}\)</span> 行列は、含まれる変数について推定したい (共) 分散を表している。予測変数である <span class="math inline">\(x\)</span> については、分散 <span class="math inline">\(\sigma^2_x\)</span> (「シグマ x 二乗」と読む) を推定する必要がある。予測変数 <span class="math inline">\(y\)</span> については、予測誤差の分散 <span class="math inline">\(\sigma^2_{e_y}\)</span> (「シグマ e y 二乗」と読む) を知りたい。したがって、<span class="math inline">\(\boldsymbol{S}\)</span> をこのように指定する。</p>
<div class="inline-figure"><img src="images/M4.png" width="20%" style="display: block; margin: auto;"></div>
<p><br></p>
<p><strong><span class="math inline">\(\boldsymbol{F}\)</span> 行列: 一方向矢印</strong></p>
<p><span class="math inline">\(\boldsymbol{F}\)</span> 行列は、モデルで<strong>観測された</strong>変数を指定することが可能である。変数が観測されたことを指定するために、単に行列のそれぞれの対角フィールドに1を挿入する。このモデルでは、<span class="math inline">\(x\)</span> と <span class="math inline">\(y\)</span> の両方が観測されているので、両方の対角フィールドに 1 を挿入する。</p>
<div class="inline-figure"><img src="images/M3.png" width="20%" style="display: block; margin: auto;"></div>
<p></p>
<p>これらの行列が設定されると、SEM のパラメータを推定することができ、指定されたモデルがどれだけデータに適合しているかを評価することができるようになる。これにはいくつか行列代数と最尤推定によるパラメータ推定が含まれるが、数学的な細かい説明はここでは省略する。このステップの背後にある詳細を理解したい場合は、<span class="citation">Cheung (<a href="references.html#ref-cheung2015meta">2015a</a>)</span> の4.3章を参照。</p>
<p><br></p>
</div>
</div>
<div id="sem-の観点からのメタ分析" class="section level3" number="11.1.2">
<h3>
<span class="header-section-number">11.1.2</span> SEM の観点からのメタ分析<a class="anchor" aria-label="anchor" href="#sem-%E3%81%AE%E8%A6%B3%E7%82%B9%E3%81%8B%E3%82%89%E3%81%AE%E3%83%A1%E3%82%BF%E5%88%86%E6%9E%90"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>ここで、メタ分析モデルと SEM に関する知識を組み合わせて、メタ分析を構造方程式モデル <span class="citation">(<a href="references.html#ref-cheung2008model">Cheung 2008</a>)</span> として定式化しよう。</p>
<p>はじめに、ランダム効果モデルの式に戻りよう。前回、メタ分析モデルがマルチレベル構造に従っていることをすでに説明してきたが (Chapter <a href="multilevel-ma.html#multilevel-nature">10.1</a>)、これは次のようなものである。</p>
<p><strong>レベル １</strong></p>
<p><span class="math display" id="eq:sem2">\[\begin{equation}
\hat\theta_k = \theta_k + \epsilon_k
\tag{11.2}
\end{equation}\]</span></p>
<p><strong>レベル ２</strong></p>
<p><span class="math display" id="eq:sem3">\[\begin{equation}
\theta_k = \mu + \zeta_k
\tag{11.3}
\end{equation}\]</span></p>
<p>最初のレベルでは、研究 <span class="math inline">\(k\)</span> で報告された効果量 <span class="math inline">\(\hat\theta_k\)</span> が、真の効果量 <span class="math inline">\(\theta_k\)</span> の推定値であると仮定する。観測された効果量が真の効果から乖離しているのは、サンプリングエラー <span class="math inline">\(\epsilon_k\)</span>、分散 <span class="math inline">\(\widehat{\text{Var}}(\hat\theta_k)=v_k\)</span> で表されるからである。</p>
<p>
</p>
<p>ランダム効果モデルでは、各研究の真の効果量でさえ、レベル２の真の効果量の母集団からしか抽出されないと仮定する。この真の効果量の母集団の平均 <span class="math inline">\(\mu\)</span> が推定したいものであり、プール効果量を表す。これを推定するためには、真の効果量の分散 <span class="math inline">\(\widehat{\text{Var}}(\theta)=\tau^2\)</span> (つまり、研究間異質性) も推定する必要がある。固定効果モデルはランダム効果モデルの特殊なケースで、<span class="math inline">\(\tau^2\)</span> がゼロであると仮定する。</p>
<p>このモデルを SEM グラフとして表現することは、非常に簡単である。レベル１のパラメータを潜在変数として、観察している効果量がどのように生まれたかを「説明」する <span class="citation">(<a href="references.html#ref-cheung2015meta">Cheung 2015a, chap. 4.6.2</a>)</span>。</p>
<div class="inline-figure"><img src="images/REM_SEM_sep.png" width="45%" style="display: block; margin: auto;"></div>
<p>モデルの図では、ある研究 <span class="math inline">\(k\)</span> の観察された効果量 <span class="math inline">\(\hat\theta_k\)</span> は、２つのアームによって「影響」されていることがわかる。２つのアームとは、分散 <span class="math inline">\(v_k\)</span> を持つサンプルエラー <span class="math inline">\(\epsilon_k\)</span>、および分散 <span class="math inline">\(\tau^2\)</span> を持つ真の効果量 <span class="math inline">\(\theta_k\)</span> である。</p>
<p><br></p>
</div>
<div id="段階メタ分析-sem-アプローチ" class="section level3" number="11.1.3">
<h3>
<span class="header-section-number">11.1.3</span> ２段階メタ分析 SEM アプローチ<a class="anchor" aria-label="anchor" href="#%E6%AE%B5%E9%9A%8E%E3%83%A1%E3%82%BF%E5%88%86%E6%9E%90-sem-%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>上記では、SEM の観点から (ランダム効果) メタ分析モデルを定義してみた。これは理論的には面白いが、このモデルは以前取り上げたメタ分析手法と比較して能力が高いわけでも低いわけでもない。単に、ランダム効果モデルを仮定して効果量をプールすることを記述しているだけである。</p>
<p>メタ分析 SEM の汎用性を本当に生かすには、２段階アプローチが必要である <span class="citation">(<a href="references.html#ref-tang2016testing">Tang and Cheung 2016</a>; <a href="references.html#ref-cheung2015meta">Cheung 2015a, chap. 7</a>)</span>。<strong>２段階構造方程式モデリング</strong> (Two-Stage Structural Equation Modeling, TSSEM) では、まず、各研究の効果量をプールする。通常、これらの効果量は、モデリングに使用する複数の変数間の相関である。 各研究 <span class="math inline">\(k\)</span> の相関は、ベクトル <span class="math inline">\(\boldsymbol{r_k} = (r_1, r_2, \dots, r_p)\)</span> で表される。ここで、 <span class="math inline">\(p\)</span> は、(ユニークな) 相関の総数である。通常のランダム効果モデルと同様に、サンプリングエラー <span class="math inline">\(\epsilon_k\)</span> と研究間の異質性 <span class="math inline">\(\zeta_k\)</span> (「ゼータ・k」と読む) により、研究 <span class="math inline">\(k\)</span> で観測された各相関は真の平均相関 <span class="math inline">\(\rho\)</span> (「ロー」と読む) から乖離すると仮定する。</p>
<p><span class="math inline">\(\boldsymbol{r_k}\)</span> が1つの研究に含まれる<strong>複数の</strong>相関を表すことを考慮すると、ランダム効果モデルの式は次のようになる。</p>
<p><span class="math display" id="eq:sem4">\[\begin{align}
  \boldsymbol{r_k} &amp;= \boldsymbol{\rho} + \boldsymbol{\zeta_k} + \boldsymbol{\epsilon_k} \notag \\
  \begin{bmatrix} r_1 \\ r_2 \\ \vdots \\ r_p \end{bmatrix} &amp;=
  \begin{bmatrix} \rho_1 \\ \rho_2 \\ \vdots \\ \rho_p \end{bmatrix} +
  \begin{bmatrix} \zeta_1 \\ \zeta_2 \\ \vdots \\ \zeta_p \end{bmatrix} +
  \begin{bmatrix} \epsilon_1 \\ \epsilon_2 \\ \vdots \\ \epsilon_p \end{bmatrix} \tag{11.4}
\end{align}\]</span></p>
<p></p>
<p>このモデルを用いて、<strong>プール</strong>相関のベクトル <span class="math inline">\(\boldsymbol{r}\)</span> を計算することが可能である。この最初のプール化ステップにより、研究間の効果の異質性を評価し、ランダム効果モデルまたはサブグループ分析を使用すべきかどうかを判断することが可能である。<strong>{metaSEM}</strong> パッケージで使用されている最尤法に基づくアプローチのおかげで、部分的にデータが欠損している研究であっても、このステップに含めることが可能である。</p>
<p></p>
<p>次に、第二段階として、<strong>加重最小二乗法</strong> ( Chapter <a href="metareg.html#metareg-model-fit">8.1.3</a> 参照) を用いて、指定した構造方程式モデルを当てはめる。指定したモデル <span class="math inline">\(\rho(\hat\theta)\)</span> の関数は、以下の式で表される <span class="citation">(<a href="references.html#ref-cheung2009two">Cheung and Chan 2009</a>; <a href="references.html#ref-cheung2015meta">Cheung 2015a, chap. 7.4.2</a>)</span>。</p>
<p><span class="math display" id="eq:sem5">\[\begin{equation}
F_{\text{WLS}}(\hat\theta) =  (\boldsymbol{r} - \rho(\hat\theta))^\top \boldsymbol{V}^{-1} (\boldsymbol{r} - \rho(\hat\theta))
\tag{11.5}
\end{equation}\]</span></p>
<p>ここで、<span class="math inline">\(\boldsymbol{r}\)</span> はプール相関ベクトルである。この式の重要な部分は、<span class="math inline">\(\boldsymbol{V}^{-1}\)</span> (「ブイ・インバース」と読む) で、これは <span class="math inline">\(\boldsymbol{r}\)</span> の共分散を含む逆行列である。この行列は、重み付けに使用される。重要なのは、この第2ステップの式は、ランダム効果モデルでも固定効果モデルでも同じである。なぜなら、研究間の異質性が存在する場合は、第1ステップですでに考慮されているからである。</p>
<p><br></p>
</div>
</div>
<div id="multivariate-ma" class="section level2" number="11.2">
<h2>
<span class="header-section-number">11.2</span> 多変量メタ分析<a class="anchor" aria-label="anchor" href="#multivariate-ma"><i class="fas fa-link"></i></a>
</h2>
<hr>
<p></p>
<p>メタ分析 SEM の最初の事例を紹介しよう。まずは、SEM 法を使った<strong>多変量メタ分析</strong>から始めたい。多変量メタ分析では、1つ以上の効果を同時に推定しようとする。このようなメタ分析は、主なアウトカムが1つだけでなく、複数あるような研究テーマを研究している場合に有効である。</p>
<p>ある種の治療の効果を調べることを想像してみよう。この治療法では、ほとんどの専門家が2種類のアウトカムを重要とみなし、したがってほとんどの研究で評価されているとしよう。多変量メタ分析では、1つのモデルで両方のアウトカムに対する効果量を<strong>共同で</strong>推定することで、この問題に対処することができる。この多変量解析のアプローチでは、2つのアウトカム間の相関を考慮することも可能である。これは、一方のアウトカムで高い効果量を持つ研究が、もう一方のアウトカムでも高い効果量を持つかどうかを判断するために使用することができる。あるいは、2つのアウトカムに負の関係があるか、まったく関係がないかがわかるだろう。</p>
<p></p>
<p>なお、多変量メタ分析は、SEMの枠組み以外でも実行可能となる <span class="citation">(<a href="references.html#ref-schwarzer2015meta">Schwarzer, Carpenter, and Rücker 2015, chap. 7</a>; <a href="references.html#ref-mvmeta">Gasparrini, Armstrong, and Kenward 2012</a>)</span>。しかし、ここでは、SEMの観点からそれらを実行する方法を紹介した。この例と次の例では、Mike Cheung <span class="citation">(<a href="references.html#ref-metasem">2015b</a>)</span>によって開発されたメタ分析 SEM のための偉大なパッケージである <strong>{metaSEM}</strong> を使用することになる。いつものように、まず <strong>{metaSEM}</strong> パッケージをインストールし、ライブラリからロードする必要がある。</p>
<div class="sourceCode" id="cb339"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/mikewlcheung/metasem">metaSEM</a></span><span class="op">)</span></span></code></pre></div>
<p></p>
<p>今回の例でも、 <strong>{dmetar}</strong> の <code>ThirdWave</code> データセットを使用する ( Chapter <a href="pooling-es.html#pre-calculated-es">4.2.1</a> を参照)。デフォルトでは、このデータセットには、知覚されたストレスに対する効果というアウトカムしか含まれていない。さて、このメタ分析のほとんどの研究が、もう1つの重要なメンタルヘルス関連のアウトカムである<strong>不安</strong>に対する効果も測定していると想像してみよう。多変量メタ分析を使用して、ストレスと不安に対する効果、および両者がどのように互いに関連しているかを共同で推定したい。</p>
<p>したがって、先に進むために両方のアウトカムのデータが含まれる新しいデータフレームを作成する必要がある。まず、各研究で報告された不安に対する効果 (Hedges’ <span class="math inline">\(g\)</span> と表す)、およびその標準誤差を含むベクトルを定義する。また、各研究で報告されたストレスと不安の間の<strong>共分散</strong>を含むベクトルも定義する必要がある。1つの研究では、不安のアウトカムを評価していないので、情報がないことを示すために、3つのベクトルで <code>NA</code> を使用する。</p>
<div class="sourceCode" id="cb340"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 不安の効果(Hedges g) を定義</span></span>
<span><span class="va">Anxiety</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.224</span>,<span class="fl">0.389</span>,<span class="fl">0.913</span>,<span class="fl">0.255</span>,<span class="fl">0.615</span>,<span class="op">-</span><span class="fl">0.021</span>,<span class="fl">0.201</span>, </span>
<span>             <span class="fl">0.665</span>,<span class="fl">0.373</span>,<span class="fl">1.118</span>,<span class="fl">0.158</span>,<span class="fl">0.252</span>,<span class="fl">0.142</span>,<span class="cn">NA</span>, </span>
<span>             <span class="fl">0.410</span>,<span class="fl">1.139</span>,<span class="op">-</span><span class="fl">0.002</span>,<span class="fl">1.084</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 不安の効果の標準偏差</span></span>
<span><span class="va">Anxiety_SE</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.193</span>,<span class="fl">0.194</span>,<span class="fl">0.314</span>,<span class="fl">0.165</span>,<span class="fl">0.270</span>,<span class="fl">0.233</span>,<span class="fl">0.159</span>,</span>
<span>                <span class="fl">0.298</span>,<span class="fl">0.153</span>,<span class="fl">0.388</span>,<span class="fl">0.206</span>,<span class="fl">0.256</span>,<span class="fl">0.256</span>,<span class="cn">NA</span>,</span>
<span>                <span class="fl">0.431</span>,<span class="fl">0.242</span>,<span class="fl">0.274</span>,<span class="fl">0.250</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># ストレスと不安の共変量</span></span>
<span><span class="va">Covariance</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.023</span>,<span class="fl">0.028</span>,<span class="fl">0.065</span>,<span class="fl">0.008</span>,<span class="fl">0.018</span>,<span class="fl">0.032</span>,<span class="fl">0.026</span>, </span>
<span>                <span class="fl">0.046</span>,<span class="fl">0.020</span>,<span class="fl">0.063</span>,<span class="fl">0.017</span>,<span class="fl">0.043</span>,<span class="fl">0.037</span>,<span class="cn">NA</span>, </span>
<span>                <span class="fl">0.079</span>,<span class="fl">0.046</span>,<span class="fl">0.040</span>,<span class="fl">0.041</span><span class="op">)</span></span></code></pre></div>
<p>そして、このデータを <code>ThirdWave</code> の情報と合わせて、<code>ThirdWaveMV</code> という新しいデータフレームを作成する。このデータセットには、効果量の<strong>分散</strong>である <code>Stress_var</code> と <code>Anxiety_var</code> を設定する。分散は、標準誤差を二乗することで得られる。</p>
<div class="sourceCode" id="cb341"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ThirdWaveMV</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>Author <span class="op">=</span> <span class="va">ThirdWave</span><span class="op">$</span><span class="va">Author</span>,</span>
<span>                          Stress <span class="op">=</span> <span class="va">ThirdWave</span><span class="op">$</span><span class="va">TE</span>,</span>
<span>                          Stress_var <span class="op">=</span> <span class="va">ThirdWave</span><span class="op">$</span><span class="va">seTE</span><span class="op">^</span><span class="fl">2</span>,</span>
<span>                          Anxiety <span class="op">=</span> <span class="va">Anxiety</span>,</span>
<span>                          Anxiety_var <span class="op">=</span> <span class="va">Anxiety_SE</span><span class="op">^</span><span class="fl">2</span>,</span>
<span>                          Covariance <span class="op">=</span> <span class="va">Covariance</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/format.html">format</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">ThirdWaveMV</span><span class="op">)</span>, digits <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<pre><code>##            Author Stress Stress_var Anxiety Anxiety_var Covariance
## 1     Call et al.   0.71      0.068   0.224       0.037      0.023
## 2 Cavanagh et al.   0.35      0.039   0.389       0.038      0.028
## 3   DanitzOrsillo   1.79      0.119   0.913       0.099      0.065
## 4  de Vibe et al.   0.18      0.014   0.255       0.027      0.008
## 5  Frazier et al.   0.42      0.021   0.615       0.073      0.018
## 6  Frogeli et al.   0.63      0.038  -0.021       0.054      0.032
</code></pre>
<p>見てわかるように、新しいデータセットには、ストレスと不安の両方の効果量が、それぞれのサンプル分散と一緒に含まれている。<code>Covariance</code> 列は、各研究で測定されたストレスと不安の間の共分散を格納している。</p>
<p>実際の研究でよくある問題は、2つのアウトカム間の共分散 (または相関) がオリジナルの研究で報告されていないことである。この場合、アウトカム間の相関に関する合理的な仮定に基づいて、共分散を<strong>推定</strong>する必要がある。</p>
<p>各研究の共分散がまだわかっていないとしよう。どのように推定できるだろうか？良い方法は、2つのアウトカム間の相関を評価した過去の文献を探すことで、今扱っているのと同じようなコンテキストで探すことができると最適である。例えば、臨床試験の介入後テストにおいて、ストレスと不安は非常に高い相関があり、<span class="math inline">\(r_{\text{S,A}} \approx\)</span> 0.6であると文献で見つけたとしよう。この想定される相関に基づいて、ある研究 <span class="math inline">\(k\)</span> の共分散を次の公式を使って近似可能である <span class="citation">(<a href="references.html#ref-schwarzer2015meta">Schwarzer, Carpenter, and Rücker 2015, chap. 7</a>)</span>。</p>
<p><span class="math display" id="eq:sem6">\[\begin{equation}
\widehat{\text{Cov}}(\theta_{1},\theta_{2}) = SE_{\theta_{1}} \times SE_{\theta_{2}} \times \hat\rho_{1, 2}
\tag{11.6}
\end{equation}\]</span></p>
<p>今回のデータを使って、<span class="math inline">\(r_{\text{S,A}} \approx\)</span> 0.6とすると、この式は <em>R</em> で次のように実装可能である。</p>
<div class="sourceCode" id="cb343"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># SE = sqrt(var) より、分散の２乗根を使用</span></span>
<span><span class="va">cov.est</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html">with</a></span><span class="op">(</span><span class="va">ThirdWaveMV</span>, </span>
<span>                <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">Stress_var</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="va">Anxiety_var</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.6</span><span class="op">)</span></span></code></pre></div>
<p>なお、このように共分散を計算する場合、想定する相関の選択によって結果に大きな影響を与えることがある。したがって、(1) 常に想定した相関係数を報告し、(2) 感度分析を行い、選んだ相関によって結果がどう変わるかを検証することが強く望まれる。</p>
<p><br></p>
<div id="モデルの指定" class="section level3" number="11.2.1">
<h3>
<span class="header-section-number">11.2.1</span> モデルの指定<a class="anchor" aria-label="anchor" href="#%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E6%8C%87%E5%AE%9A"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>多変量メタ分析モデルを指定するために、プログラム的に TSSEM 手順 (前章参照) に従う必要はないし、RAM 行列を指定する必要もない。このような比較的単純なモデルであれば、 <strong>{metaSEM}</strong> の <code>meta</code> 関数を使用すれば、たった1ステップでメタ分析 SEM を適用することが可能である。<code>meta</code> を使用するには、3つの必須引数を指定するだけである。</p>
<ul>
<li><p><strong><code>y</code></strong>. 効果量データを含むデータセットの列である。多変量メタ分析では、<code>cbind</code> を用いて、効果量を含む列を結合する必要がある。</p></li>
<li><p><strong><code>v</code></strong>. 効果量の分散を含むデータセットの列。多変量メタ分析では、<code>cbind</code> を用いて、対象とする分散列を結合する必要がある。また、効果量間の共分散を含む列も含める必要がある。引数の構造は <code>cbind(variance_1, covariance, variance_2)</code> である。</p></li>
<li><p><strong><code>data</code></strong>. 効果量と分散が格納されたデータセット。</p></li>
</ul>
<p>適合したモデルを <code>m.mv</code> という名前で保存する。ひとつ重要な点として、<code>meta</code> を実行する前に、<strong>{meta}</strong> パッケージがロードされて<strong>いない</strong>ことを確認しておこう。<strong>{meta}</strong> と <strong>{metaSEM}</strong> の関数は同じ名前を持って流物がいくつかあり、 <em>R</em> でコードを実行するときにエラーにつながる可能性がある。<code>detach</code> 関数を使ってパッケージを “unload” することが可能である。</p>
<p>結果として得られる <code>m.mv</code> オブジェクトは、<code>summary</code> を用いて検証したい。</p>
<div class="sourceCode" id="cb344"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.mv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/meta.html">meta</a></span><span class="op">(</span>y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">Stress</span>, <span class="va">Anxiety</span><span class="op">)</span>, </span>
<span>             v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">Stress_var</span>, <span class="va">Covariance</span>, <span class="va">Anxiety_var</span><span class="op">)</span>,</span>
<span>             data <span class="op">=</span> <span class="va">ThirdWaveMV</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">m.mv</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [...]
## Coefficients:
##            Estimate Std.Error lbound ubound z value Pr(&gt;|z|)    
## Intercept1    0.570     0.087  0.399  0.740  6.5455  5.9e-13 ***
## Intercept2    0.407     0.083  0.244  0.570  4.9006  9.5e-09 ***
## Tau2_1_1      0.073     0.049 -0.023  0.169  1.4861   0.1372    
## Tau2_2_1      0.028     0.035 -0.041  0.099  0.8040   0.4214    
## Tau2_2_2      0.057     0.042 -0.025  0.140  1.3643   0.1725    
## ---
## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
## [...]
## 
## Heterogeneity indices (based on the estimated Tau2):
##                              Estimate
## Intercept1: I2 (Q statistic)   0.6203
## Intercept2: I2 (Q statistic)   0.5292
## 
## Number of studies (or clusters): 18
## [...]
## OpenMx status1: 0 ("0" or "1": The optimization is considered fine.
## Other values may indicate problems.)</code></pre>
<p><br></p>
</div>
<div id="結果の評価" class="section level3" number="11.2.2">
<h3>
<span class="header-section-number">11.2.2</span> 結果の評価<a class="anchor" aria-label="anchor" href="#%E7%B5%90%E6%9E%9C%E3%81%AE%E8%A9%95%E4%BE%A1"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p></p>
<p>SEM モデルが最尤法を使って適合していることを考えると、まず出力の最後にある <code>OpenMx status</code> を最初にチェックする。最尤推定は最適化手順であり、手元のデータに対する最適解が見つかるまで、パラメータが繰り返し変更される。しかし、特に複雑なモデルでは、何度繰り返しても最適解に到達しないことがある。その場合、最尤法は停止して、これまでに近似したパラメータ値を出力した。しかし、このようなモデルの構成要素の値は間違っている可能性が高く、信用するべきではない。</p>
<p>このモデルの <code>OpenMx status</code> は <code>0</code> であり、最尤推定がうまくいったことを示している。もし、このステータスが 0 または 1 以外であった場合、このコードを使ってモデルを再実行する必要がある。</p>
<div class="sourceCode" id="cb346"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/rerun.html">rerun</a></span><span class="op">(</span><span class="va">m.mv</span><span class="op">)</span></span></code></pre></div>
<p>この出力では、プールされた2つの効果量が <code>Intercept1</code> と <code>Intercept2</code> として表示される。効果量は、<code>meta</code> の呼び出しに挿入した順番に番号が振られている。プールされた効果量は、<span class="math inline">\(g_{\text{Stress}}\)</span> = 0.57 および <span class="math inline">\(g_{\text{Anxiety}}\)</span> = 0.41であることがわかる。どちらの効果量も有意である。異質性指標では、<span class="math inline">\(I^2\)</span> の値も見ることが可能である。 <span class="math inline">\(I^2_{\text{Stress}}\)</span> = 62% と <span class="math inline">\(I^2_{\text{Anxiety}}\)</span> = 53%で、両方のアウトカムにかなりの研究間異質性があることがわかる。</p>
<p>また、研究間異質性分散 <span class="math inline">\(\tau^2\)</span> の直接推定値も示されている。2つの推定値だけでなく、3つの推定値があることがわかる。この意味を理解するために、<code>m.mv</code> オブジェクトから「ランダム」な値を抽出することが可能である。</p>
<div class="sourceCode" id="cb347"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tau.coefs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">m.mv</span>, select <span class="op">=</span> <span class="st">"random"</span><span class="op">)</span></span></code></pre></div>
<p>次に、<code>vec2symMat</code> 関数を使用して、係数行列を作成する。行列の行と列には、変数名である <code>Stress</code> と <code>Anxiety</code> を付ける。</p>
<div class="sourceCode" id="cb348"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 行列を作成</span></span>
<span><span class="va">tc.mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/vec2symMat.html">vec2symMat</a></span><span class="op">(</span><span class="va">tau.coefs</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 列名と行名をつける</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">tc.mat</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">tc.mat</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Stress"</span>, </span>
<span>                                                    <span class="st">"Anxiety"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">tc.mat</span></span></code></pre></div>
<pre><code>##             Stress    Anxiety
## Stress  0.07331199 0.02894342
## Anxiety 0.02894342 0.05753271</code></pre>
<p>ここで、<span class="math inline">\(\tau^2\)</span> の3つの値の意味がよくわかる。これらは、行列の対角線上の研究間分散 (異質性) を表している。他の2つのフィールドでは、行列はストレスと不安の間の推定共分散を示している。共分散は相関の未標準化バージョンに過ぎないので、<code>cov2cor</code> 関数を用いて、これらの値を相関に変換することが可能である。</p>
<div class="sourceCode" id="cb350"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">cov2cor</a></span><span class="op">(</span><span class="va">tc.mat</span><span class="op">)</span></span></code></pre></div>
<pre><code>##            Stress   Anxiety
## Stress  1.0000000 0.4456613
## Anxiety 0.4456613 1.0000000</code></pre>
<p>極めて論理的に、行列の対角要素の相関は1であることがわかる。ストレスと不安に対する効果の相関は、<span class="math inline">\(r_{\text{S,A}}\)</span> = 0.45 である。これは興味深い発見で、治療法の知覚ストレスに対する効果と不安に対する効果との間に正の相関があることを示している。ストレスに対する効果が高い治療法は、不安に対する効果も高いようだと言うことが可能である。</p>
<p></p>
<p><code>m.mv</code> の要約で示される信頼区間は Wald 型の区間であることに注意しておこう (Chapter <a href="pooling-es.html#knapp-hartung">4.1.2.2</a> を参照)。このような Wald タイプの信頼区間は、特に小さなサンプルでは不正確な場合がある <span class="citation">(<a href="references.html#ref-diciccio1996bootstrap">DiCiccio and Efron 1996</a>)</span>。したがって、<strong>尤度に基づく</strong>信頼区間を用いて、別の方法で信頼区間を構築することが重要である場合がある。<code>meta</code> 関数を再実行し、さらに <code>intervals.type = "LB"</code> を指定することで、これらの CI を得ることが可能である。</p>
<div class="sourceCode" id="cb352"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.mv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/meta.html">meta</a></span><span class="op">(</span>y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">Stress</span>, <span class="va">Anxiety</span><span class="op">)</span>, </span>
<span>             v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">Stress_var</span>, <span class="va">Covariance</span>, <span class="va">Anxiety_var</span><span class="op">)</span>,</span>
<span>             data <span class="op">=</span> <span class="va">ThirdWaveMV</span>,</span>
<span>             intervals.type <span class="op">=</span> <span class="st">"LB"</span><span class="op">)</span></span></code></pre></div>
<p><code>m.mv</code> の出力には、研究間異質性 <span class="math inline">\(\tau^2\)</span> のゼロでない推定値が含まれていることがすでにわかった。したがって、今適合したモデルは、ランダム効果モデルであると結論づけることが可能である。<code>meta</code> 関数は自動的にランダム効果モデルを使用する。出力された <span class="math inline">\(I^2\)</span> の値を考慮すると、これは確かに適切であると結論づけることが可能である。しかし、固定効果モデルを適用したい場合は、解析を再実行し、パラメータ <code>RE.constraints = matrix(0, nrow=2, ncol=2)</code> を追加することで、適用することが可能である。これは、<span class="math inline">\(\tau^2\)</span> の値をすべて0に拘束する零行列を作成する。</p>
<div class="sourceCode" id="cb353"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m.mv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/meta.html">meta</a></span><span class="op">(</span>y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">Stress</span>, <span class="va">Anxiety</span><span class="op">)</span>, </span>
<span>             v <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">Stress_var</span>, <span class="va">Covariance</span>, <span class="va">Anxiety_var</span><span class="op">)</span>,</span>
<span>             data <span class="op">=</span> <span class="va">ThirdWaveMV</span>,</span>
<span>             RE.constraints <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>, nrow<span class="op">=</span><span class="fl">2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><br></p>
</div>
<div id="結果の可視化" class="section level3" number="11.2.3">
<h3>
<span class="header-section-number">11.2.3</span> 結果の可視化<a class="anchor" aria-label="anchor" href="#%E7%B5%90%E6%9E%9C%E3%81%AE%E5%8F%AF%E8%A6%96%E5%8C%96"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>多変量メタ分析モデルをプロットするには、<code>plot</code> 関数を使用する。また、プロットの外観を変更するために、いくつかの追加指定を行う。全てのスタイリングオプションを見たい場合は、コンソールに <code><a href="https://rdrr.io/pkg/metaSEM/man/plot.html">?metaSEM::plot.meta</a></code> を貼り付けて、Enterキーを押してみよう。</p>
<div class="sourceCode" id="cb354"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">m.mv</span>, </span>
<span>     axis.labels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Perceived Stress"</span>, <span class="st">"Anxiety"</span><span class="op">)</span>, </span>
<span>     randeff.ellipse.col <span class="op">=</span> <span class="st">"#014d64"</span>,</span>
<span>     univariate.arrows.col <span class="op">=</span> <span class="st">"gray40"</span>,</span>
<span>     univariate.arrows.lwd <span class="op">=</span> <span class="fl">9</span>,</span>
<span>     univariate.polygon.col <span class="op">=</span> <span class="st">"gray40"</span>,</span>
<span>     estimate.ellipse.col <span class="op">=</span> <span class="st">"gray40"</span>,</span>
<span>     estimate.col <span class="op">=</span> <span class="st">"firebrick"</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="Doing_Meta_Analysis_in_R_files/figure-html/unnamed-chunk-319-1.png" width="60%" style="display: block; margin: auto;"></div>
<p>それでは、見ていこう。プロットには2つの軸がある: ストレスへの効果を示す x 軸と、不安への効果を示す y 軸である。また、両方のアウトカムに対するプール効果とその95%信頼区間が表示されている (黒い菱形で表されている)。</p>
<p></p>
<p>プロットの中央には、両変数のプール効果が赤い菱形で示されている。小さい青い楕円は、私たちのプールされた効果の95%信頼区間を表し、大きい黒い楕円は、95%<strong>予測</strong>区間を表している (Chapter <a href="heterogeneity.html#het-measure-which">5.2</a>) <a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;これらの予測区間 (または「もっともらしい値間隔」) は、&lt;strong&gt;{meta}&lt;/strong&gt; および &lt;strong&gt;{metafor}&lt;/strong&gt; が使用する式 (Chapter &lt;a href="heterogeneity.html#het-measure-which"&gt;5.2&lt;/a&gt; の 5.7 式) と異なる式 &lt;span class="citation"&gt;(&lt;span class="math inline"&gt;\(\hat\mu \pm 1.96 \times \hat\tau\)&lt;/span&gt;, &lt;a href="references.html#ref-raudenbush2009pi"&gt;Raudenbush 2009&lt;/a&gt;)&lt;/span&gt; に基づき、わずかに狭い間隔になっている&lt;/p&gt;'><sup>59</sup></a>。</p>
<p>最後に、黒丸は個々の研究を示し、破線の楕円は95%信頼区間を表す。</p>
<p><br></p>
</div>
</div>
<div id="cfa" class="section level2" number="11.3">
<h2>
<span class="header-section-number">11.3</span> 確証的因子分析<a class="anchor" aria-label="anchor" href="#cfa"><i class="fas fa-link"></i></a>
</h2>
<hr>
<p></p>
<p>確証的因子分析 (Confirmatory Factor Analysis, CFA) は、観測された変数が仮定された潜在変数にどのように関係するかを特定する一般的な SEM 手法である <span class="citation">(<a href="references.html#ref-thompson2004exploratory">B. Thompson 2004, chap. 1.1</a> and 1.2)</span>。CFA は、アンケートや他のタイプのアセスメントの心理測定特性を評価するためによく使用される。それは、研究者が、評価された変数が、測定しようとする潜在変数を本当に測定しているかどうか、および複数の潜在変数がお互いにどのように関係するかを決定することを可能にする。</p>
<p>頻繁に使用されるアンケートについては、通常、異なるアンケート項目間の相関を報告する多くの実証研究が存在した。このようなデータは、メタ分析的な SEM に使用することが可能である。これにより、すべての利用可能なエビデンスに基づいて、どの潜在因子構造が最も適切であるかを評価することが可能である。</p>
<p>この例では、睡眠の問題についての (架空の) 質問票の潜在的な因子構造を確認したい。質問票には、睡眠の問題を特徴づける2つの異なる潜在変数を測定すると仮定する。<strong>不眠症</strong> (insomnia) と<strong>倦怠感</strong> (lassitude、一般的に倦怠感は fatigue) である。Koffel and Watson <span class="citation">(<a href="references.html#ref-koffel2009two">2009</a>)</span> は、睡眠の訴えは、実際にこれらの2つの潜在因子によって記述され得ると主張した。</p>
<p>メタ分析 CFA を実践するために、私たちが想像した睡眠アンケートを評価した11件の研究結果をシミュレートした。このデータセットを <code>SleepProblems</code> と名付けた。これらの研究のそれぞれには、私たちの質問票によって直接測定された睡眠に関する不満の症状間の相互相関が含まれている。これらの測定指標には、睡眠の質、睡眠潜時、睡眠効率、日中機能不全、<strong>hypersomnia</strong> (すなわち、寝過ぎ) が含まれる。最初の3つの症状は、いずれも不眠症を潜在変数として測定しているので関連があり、日中機能不全と過眠症は、倦怠感要因の症状なので関連があると推測される。</p>
<p>提案された構造をグラフィカルなモデルとして表現すると、次のようになる<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;パス図のラベルは、後でモデルの関連コンポーネントを識別しやすくするために、多少「特異」であることに注意してみよう&lt;/p&gt;"><sup>60</sup></a>。</p>
<div class="inline-figure"><img src="images/CFA_Graph-1_sep.png" width="60%" style="display: block; margin: auto;"></div>
<p><br></p>
<div id="データ準備" class="section level3" number="11.3.1">
<h3>
<span class="header-section-number">11.3.1</span> データ準備<a class="anchor" aria-label="anchor" href="#%E3%83%87%E3%83%BC%E3%82%BF%E6%BA%96%E5%82%99"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>まず、モデルに使用する <code>SleepProblems</code> データを見てみよう。このデータセットは特殊な構造を持っている。それは <code>list</code> オブジェクトであり、(1) 行列の <code>list</code> と (2) 数値ベクトルを含んでいる。リストは非常に汎用性の高い <em>R</em> オブジェクトであり、異なる要素を 1 つの大きなオブジェクトに結合することが可能である。リストは <code>$</code> 演算子を用いて、データフレームのようにアクセスすることができる。<code>names</code> 関数を使用すると、リスト内のオブジェクトの名前を表示すことが可能である。</p>
<div class="boxdmetar">
<p>
<strong>“SleepProblems” データセット</strong>
</p>
<p>
<code>SleepProblems</code> データセットは <strong>{dmetar}</strong>
パッケージに含まれている。<strong>{dmetar}</strong>
をインストールし、ライブラリからロードした後、
<code>data(TherapyFormatsGeMTC)</code>
を実行すると、自動的にデータセットが <em>R</em>
環境にセーブされる。これでデータセットが利用できるようになる。
</p>
<p>
もし、<strong>{dmetar}</strong> がインストールされていない場合は、<a href="https://www.protectlab.org/meta-analysis-in-r/data/SleepProblems.rda">インターネット</a>
から <em>.rda</em>
ファイルとしてダウンロードし、作業ディレクトリに保存した後、R Studio
のウィンドウでクリックするとインポートすることが可能である。
</p>
</div>
<div class="sourceCode" id="cb355"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">SleepProblems</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">SleepProblems</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "data" "n"</code></pre>
<p>このリストには、実際の <code>data</code> と、各研究のサンプルサイズである <code>n</code> の 2 つの要素が含まれていることがわかる。<code>data</code> オブジェクトはそれ自体が <code>list</code> であるため、 <code>names</code> 関数を使用してそのコンテンツの名前を取得することも可能である。</p>
<div class="sourceCode" id="cb357"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">SleepProblems</span><span class="op">$</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<pre><code>## [1] "Coleman et al. (2003)"  "Salazar et al. (2008)" 
## [3] "Newman et al. (2016)"   "Delacruz et al. (2009)"
## [5] "Wyatt et al. (2002)"    "Pacheco et al. (2016)"
## [...]</code></pre>
<p>また、<code>$</code> 演算子を使って <code>data</code> に含まれる特定の要素を表示すことも可能である。</p>
<div class="sourceCode" id="cb359"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">SleepProblems</span><span class="op">$</span><span class="va">data</span><span class="op">$</span><span class="va">`Coleman et al. (2003)`</span></span></code></pre></div>
<pre><code>##            Quality Latency Efficiency DTDysf HypSomnia
## Quality       1.00    0.39       0.53  -0.30     -0.05
## Latency       0.39    1.00       0.59   0.07      0.44
## Efficiency    0.53    0.59       1.00   0.09      0.22
## DTDysf       -0.30    0.07       0.09   1.00      0.45
## HypSomnia    -0.05    0.44       0.22   0.45      1.00</code></pre>
<p><code>data</code> リストには11の要素があり、含まれる11の研究ごとに1つずつある。Coleman et al. (2003) の研究を詳しく見ると、データは5つの変数を持つ相関行列として格納されていることがわかる。行列の各行と列は、私たちの質問票で評価された睡眠の不定愁訴の症状の1つに対応した。</p>
<p>Coleman et al. (2003) の研究では、各症状の組み合わせについて相関が報告されている。しかし、いくつかのフィールドで欠損値 ( <code>NA</code> としてコード化) を持つ研究を使用することも可能である。これは、メタ分析SEMが、少なくともある程度は、欠損データを扱うことができることがある。</p>
<p>先に進む前に、このようなリストを自分で作成する方法を簡単に説明しよう。2つの研究の相関行列を抽出し、それをデータフレームとして <em>R</em> にインポートしたい。データフレームを <code>df1</code> と <code>df2</code> と呼ぶとすると、以下の「レシピ」を使用して、さらなる解析に適した <code>list</code> オブジェクトを作成することが可能である。</p>
<div class="sourceCode" id="cb361"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># データフレームを行列に変換</span></span>
<span><span class="va">mat1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">df1</span><span class="op">)</span></span>
<span><span class="va">mat2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span><span class="op">(</span><span class="va">df2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 行ラベルを定義</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">mat1</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Variable 1"</span>, <span class="st">"Variable 2"</span>, <span class="st">"Variable 3"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">mat2</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Variable 1"</span>, <span class="st">"Variable 2"</span>, <span class="st">"Variable 3"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># リストに相関係数行列を結合</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">mat1</span>, <span class="va">mat2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/names.html">names</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Study1"</span>, <span class="st">"Study2"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 二つの研究のサンプルサイズを定義</span></span>
<span><span class="va">n</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">205</span>, <span class="co"># N of study 1</span></span>
<span>       <span class="fl">830</span><span class="op">)</span> <span class="co"># N of study 2</span></span>
<span></span>
<span><span class="co"># 行列とサンプルサイズを結合</span></span>
<span><span class="va">cfa.data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">data</span>, <span class="va">n</span><span class="op">)</span></span></code></pre></div>
<p><br></p>
</div>
<div id="モデル仕様-1" class="section level3" number="11.3.2">
<h3>
<span class="header-section-number">11.3.2</span> モデル仕様<a class="anchor" aria-label="anchor" href="#%E3%83%A2%E3%83%87%E3%83%AB%E4%BB%95%E6%A7%98-1"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>CFA モデルを指定するためには、先に述べた RAM 指定と２段階メタ分析 SEM 手順を使用する必要がある。<strong>{metaSEM}</strong> パッケージは、２段階のそれぞれについて、<code>tssem1</code> と <code>tssem2</code> という別々の関数を含んでいる。最初の関数は、すべての研究の相関行列をプールし、２番目の関数は、提案されたモデルをデータに適合させる。</p>
<p><br></p>
<div id="ステージ-1" class="section level4" number="11.3.2.1">
<h4>
<span class="header-section-number">11.3.2.1</span> ステージ 1<a class="anchor" aria-label="anchor" href="#%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8-1"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p>最初の段階では、<code>tssem1</code> 関数を用いて相関行列をプールする。この関数では、4つの重要な引数を指定する必要がある。</p>
<ul>
<li><p><strong><code>Cov</code></strong>. プールしたい相関行列の <code>list</code> を指定する。リスト内のすべての相関行列は、同一の構造を持っている必要があることに注意。</p></li>
<li><p><strong><code>n</code></strong>. 各研究のサンプルサイズを含む数値ベクトルで、<code>Cov</code> に含まれる行列と同じ順序で並べられる。</p></li>
<li><p><strong><code>method</code></strong>. 固定効果モデル (<code>"FEM"</code>) またはランダム効果モデル (<code>"REM"</code>) を使用するかどうかを指定。</p></li>
<li><p><strong><code>RE.type</code></strong>. ランダム効果モデルを利用する場合、ランダム効果の推定方法を指定する。デフォルトは <code>"Symm"</code> で、2つの変数間の共分散を含む、すべての <span class="math inline">\(\tau^2\)</span> の値を推定する。<code>"Diag"</code> に設定すると、ランダム効果行列の対角要素のみが推定される。これは、ランダム効果が独立であると仮定していることを意味する。<code>"Diag"</code> を設定すると、モデルは非常に単純化されるが、推定しなければならないパラメータが少なくなるため、多くの場合、この方法が望ましい。これは変数の数が多い場合や研究の数が少ない場合に特に意味がある。</p></li>
</ul>
<p>この例では、ランダム効果モデルを仮定し、<code>RE.type = "Diag"</code> を使用する。モデルを <code>cfa1</code> として保存し、出力を取得するために <code>summary</code> 関数を呼び出す。</p>
<div class="sourceCode" id="cb362"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cfa1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/tssem1.html">tssem1</a></span><span class="op">(</span><span class="va">SleepProblems</span><span class="op">$</span><span class="va">data</span>, </span>
<span>               <span class="va">SleepProblems</span><span class="op">$</span><span class="va">n</span>, </span>
<span>               method<span class="op">=</span><span class="st">"REM"</span>,</span>
<span>               RE.type <span class="op">=</span> <span class="st">"Diag"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">cfa1</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 
## Call:
## meta(y = ES, v = acovR, RE.constraints = Diag(paste0(RE.startvalues, 
##     "*Tau2_", 1:no.es, "_", 1:no.es)), RE.lbound = RE.lbound, 
##     I2 = I2, model.name = model.name, suppressWarnings = TRUE, 
##     silent = silent, run = run)
## 
## 95% confidence intervals: z statistic approximation (robust=FALSE)
## Coefficients:
##                 Estimate    Std.Error       lbound       ubound z value
## Intercept1   0.444432236  0.057467775  0.331797465  0.557067006  7.7336
## Intercept2   0.478173063  0.042506058  0.394862720  0.561483407 11.2495
## Intercept3   0.032786305  0.071282427 -0.106924685  0.172497295  0.4599
## Intercept4   0.132711876  0.048151188  0.038337281  0.227086471  2.7561
## Intercept5   0.509594150  0.036490787  0.438073522  0.581114778 13.9650
## Intercept6   0.120881305  0.040915599  0.040688204  0.201074406  2.9544
## Intercept7   0.192545120  0.060739565  0.073497760  0.311592481  3.1700
## Intercept8   0.221265205  0.039608121  0.143634715  0.298895695  5.5864
## Intercept9   0.189786602  0.045589099  0.100433611  0.279139594  4.1630
## Intercept10  0.509204468  0.023983697  0.462197284  0.556211651 21.2313
## Tau2_1_1     0.032324879  0.015012416  0.002901083  0.061748674  2.1532
## Tau2_2_2     0.016349084  0.008326703  0.000029047  0.032669121  1.9635
## Tau2_3_3     0.049769970  0.023797989  0.003126768  0.096413171  2.0914
## Tau2_4_4     0.019828043  0.010038215  0.000153503  0.039502583  1.9753
## Tau2_5_5     0.010963532  0.006133040 -0.001057005  0.022984070  1.7876
## Tau2_6_6     0.012511016  0.007794974 -0.002766852  0.027788883  1.6050
## Tau2_7_7     0.034863896  0.016839497  0.001859088  0.067868704  2.0704
## Tau2_8_8     0.012156429  0.006571848 -0.000724157  0.025037015  1.8498
## Tau2_9_9     0.017532003  0.009481599 -0.001051590  0.036115595  1.8491
## Tau2_10_10   0.003543432  0.002549068 -0.001452649  0.008539512  1.3901
##                          Pr(&gt;|z|)    
## Intercept1    0.00000000000001044 ***
## Intercept2  &lt; 0.00000000000000022 ***
## Intercept3               0.645553    
## Intercept4               0.005849 ** 
## Intercept5  &lt; 0.00000000000000022 ***
## Intercept6               0.003133 ** 
## Intercept7               0.001524 ** 
## Intercept8    0.00000002318788406 ***
## Intercept9    0.00003141179890975 ***
## Intercept10 &lt; 0.00000000000000022 ***
## Tau2_1_1                 0.031302 *  
## Tau2_2_2                 0.049594 *  
## Tau2_3_3                 0.036497 *  
## Tau2_4_4                 0.048239 *  
## Tau2_5_5                 0.073838 .  
## Tau2_6_6                 0.108491    
## Tau2_7_7                 0.038418 *  
## Tau2_8_8                 0.064346 .  
## Tau2_9_9                 0.064450 .  
## Tau2_10_10               0.164502    
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Q statistic on the homogeneity of effect sizes: 908.1438
## Degrees of freedom of the Q statistic: 100
## P value of the Q statistic: 0
## 
## Heterogeneity indices (based on the estimated Tau2):
##                               Estimate
## Intercept1: I2 (Q statistic)    0.9316
## Intercept2: I2 (Q statistic)    0.8837
## Intercept3: I2 (Q statistic)    0.9336
## Intercept4: I2 (Q statistic)    0.8547
## Intercept5: I2 (Q statistic)    0.8315
## Intercept6: I2 (Q statistic)    0.7800
## Intercept7: I2 (Q statistic)    0.9093
## Intercept8: I2 (Q statistic)    0.7958
## Intercept9: I2 (Q statistic)    0.8366
## Intercept10: I2 (Q statistic)   0.6486
## 
## Number of studies (or clusters): 11
## Number of observed statistics: 110
## Number of estimated parameters: 20
## Degrees of freedom: 90
## -2 log likelihood: -100.688 
## OpenMx status1: 0 ("0" or "1": The optimization is considered fine.
## Other values may indicate problems.)</code></pre>
<pre><code>[...]
Coefficients:
           Estimate Std.Error lbound  ubound z value Pr(&gt;|z|)    
Intercept1    0.444     0.057  0.331   0.557   7.733  &lt; 0.001 ***
Intercept2    0.478     0.042  0.394   0.561  11.249  &lt; 0.001 ***
Intercept3    0.032     0.071 -0.106   0.172   0.459    0.645    
Intercept4    0.132     0.048  0.038   0.227   2.756    0.005 ** 
Intercept5    0.509     0.036  0.438   0.581  13.965  &lt; 0.001 ***
Intercept6    0.120     0.040  0.040   0.201   2.954    0.003 ** 
Intercept7    0.192     0.060  0.073   0.311   3.170    0.001 ** 
Intercept8    0.221     0.039  0.143   0.298   5.586  &lt; 0.001 ***
Intercept9    0.189     0.045  0.100   0.279   4.163  &lt; 0.001 ***
Intercept10   0.509     0.023  0.462   0.556  21.231  &lt; 0.001 ***
Tau2_1_1      0.032     0.015  0.002   0.061   2.153    0.031 *  
Tau2_2_2      0.016     0.008  0.000   0.032   1.963    0.049 *  
Tau2_3_3      0.049     0.023  0.003   0.096   2.091    0.036 *  
Tau2_4_4      0.019     0.010  0.000   0.039   1.975    0.048 *  
Tau2_5_5      0.010     0.006 -0.001   0.022   1.787    0.073 .  
Tau2_6_6      0.012     0.007 -0.002   0.027   1.605    0.108    
Tau2_7_7      0.034     0.016  0.001   0.067   2.070    0.038 *  
Tau2_8_8      0.012     0.006 -0.000   0.025   1.849    0.064 .  
Tau2_9_9      0.017     0.009 -0.001   0.036   1.849    0.064 .  
Tau2_10_10    0.003     0.002 -0.001   0.008   1.390    0.164    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
[...]

Heterogeneity indices (based on the estimated Tau2):
                              Estimate
Intercept1: I2 (Q statistic)    0.9316
Intercept2: I2 (Q statistic)    0.8837
Intercept3: I2 (Q statistic)    0.9336
Intercept4: I2 (Q statistic)    0.8547
Intercept5: I2 (Q statistic)    0.8315
Intercept6: I2 (Q statistic)    0.7800
Intercept7: I2 (Q statistic)    0.9093
Intercept8: I2 (Q statistic)    0.7958
Intercept9: I2 (Q statistic)    0.8366
Intercept10: I2 (Q statistic)   0.6486

[...]
OpenMx status1: 0 ("0" or "1": The optimization is considered fine.
Other values may indicate problems.)</code></pre>
<p><code>OpenMx status</code> を見ると、モデルの推定値が信頼できるものであることが確認可能である。結果をより消化しやすくするために、<code>coef</code> 関数を用いて固定効果 (私たちの推定したプール相関) を抽出することが可能である。次に、<code>vec2symMat</code> を用いて係数から対称行列を作成し、解釈を容易にするために次元名を追加する。</p>
<div class="sourceCode" id="cb365"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 固定係数 (相関) を抽出</span></span>
<span><span class="va">fixed.coefs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">cfa1</span>, <span class="st">"fixed"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 対称行列を作成</span></span>
<span><span class="va">fc.mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/vec2symMat.html">vec2symMat</a></span><span class="op">(</span><span class="va">fixed.coefs</span>, diag <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 列名と行名をつける</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">fc.mat</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Quality"</span>, <span class="st">"Latency"</span>, </span>
<span>                           <span class="st">"Efficiency"</span>, <span class="st">"DTDysf"</span>, <span class="st">"HypSomnia"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">fc.mat</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Quality"</span>, <span class="st">"Latency"</span>, </span>
<span>                           <span class="st">"Efficiency"</span>, <span class="st">"DTDysf"</span>, <span class="st">"HypSomnia"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 相関行列を表示 (３桁) </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">round</a></span><span class="op">(</span><span class="va">fc.mat</span>, <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<pre><code>##            Quality Latency Efficiency DTDysf HypSomnia
## Quality      1.000   0.444      0.478  0.033     0.133
## Latency      0.444   1.000      0.510  0.121     0.193
## Efficiency   0.478   0.510      1.000  0.221     0.190
## DTDysf       0.033   0.121      0.221  1.000     0.509
## HypSomnia    0.133   0.193      0.190  0.509     1.000</code></pre>
<p>これで、変数のプールされた相関行列を見ることが可能である。モデルの出力を見てみると、すべての相関係数が有意であることがわかる ( <span class="math inline">\(p&lt;\)</span> 0.05) ただし、1つだけ、睡眠の質と日中機能不全の相関は有意ではなかった。私たちの想定したモデルの観点からは、これらの変数が異なる因子に負荷されると予想されるので、これは理にかなっている。また、異なる推定値の <span class="math inline">\(I^2\)</span> 値が非常に大きい (65-93%) ことがわかる。</p>
<p><br></p>
</div>
<div id="ステージ-2" class="section level4" number="11.3.2.2">
<h4>
<span class="header-section-number">11.3.2.2</span> ステージ 2<a class="anchor" aria-label="anchor" href="#%E3%82%B9%E3%83%86%E3%83%BC%E3%82%B8-2"><i class="fas fa-link"></i></a>
</h4>
<hr>
<p>相関行列をプールした後、提案した因子モデルがデータにうまく適合しているかどうかを判断することになる。モデルを指定するために、今回は RAM 式を使用し、<span class="math inline">\(\boldsymbol{A}\)</span>, <span class="math inline">\(\boldsymbol{S}\)</span>, <span class="math inline">\(\boldsymbol{F}\)</span> という行列を指定する必要がある。これら行列の各フィールドを埋めるために、最初に空行列を構築することが最善であることがよくある。構造的には、私たちが定義したすべて行列は、観測変数だけでなく、仮定した潜在変数である <code>f_Insomnia</code> と <code>f_Lassitude</code> も含んでいる。ここでは、出発点としてゼロ行列を作成する方法を示した。</p>
<div class="sourceCode" id="cb367"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 行と列の名称のベクトルを作成</span></span>
<span><span class="va">dims</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"Quality"</span>, <span class="st">"Latency"</span>, <span class="st">"Efficiency"</span>, </span>
<span>          <span class="st">"DTDysf"</span>, <span class="st">"HypSomnia"</span>, <span class="st">"f_Insomnia"</span>, <span class="st">"f_Lassitude"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 7x7 のゼロ行列を作成</span></span>
<span><span class="va">mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">7</span><span class="op">*</span><span class="fl">7</span><span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">7</span>, ncol <span class="op">=</span> <span class="fl">7</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 列名と行名をつける</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">mat</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dims</span></span>
<span><span class="va">mat</span></span></code></pre></div>
<pre><code>##             Qlty Ltncy Effcncy DTDysf HypSmn f_Insmn f_Lsstd
## Quality        0     0       0      0      0       0       0
## Latency        0     0       0      0      0       0       0
## Efficiency     0     0       0      0      0       0       0
## DTDysf         0     0       0      0      0       0       0
## HypSomnia      0     0       0      0      0       0       0
## f_Insomnia     0     0       0      0      0       0       0
## f_Lassitude    0     0       0      0      0       0       0</code></pre>
<p><br></p>
<p><span class="math inline">\(\boldsymbol{A}\)</span> <strong>行列</strong></p>
<p><span class="math inline">\(\boldsymbol{A}\)</span> 行列では、モデルにおける非対称 (つまり単一) 矢印を指定する。各単一矢印は列変数から始まり、列が行変数のエントリと交差するところで終わる。矢印を表さない他のフィールドはすべて <code>0</code> で埋められる。</p>
<p><span class="math inline">\(\boldsymbol{A}\)</span> 行列に文字列を追加することで、矢印を「推定」しなければならないことを指定する。この文字列は、最適化手順の開始値 (通常は 0.1 から 0.3 の間のどこか) で始まり、その後に <code>*</code> が続く。記号の後に、その値のラベルを指定する。<span class="math inline">\(\boldsymbol{A}\)</span> 行列の2つのフィールドが同じラベルを持つ場合、これはそのフィールドが同じ値を持つと仮定することを意味する。</p>
<p>この例では、すべての推定矢印の開始値を 0.3 とし、先に示した経路図に従ってフィールドにラベル付けを行う。</p>
<div class="sourceCode" id="cb369"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="st">"0.3*Ins_Q"</span>, <span class="fl">0</span>          ,</span>
<span>              <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="st">"0.3*Ins_L"</span>, <span class="fl">0</span>          ,</span>
<span>              <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="st">"0.3*Ins_E"</span>, <span class="fl">0</span>          ,</span>
<span>              <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>          , <span class="st">"0.3*Las_D"</span>,</span>
<span>              <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>          , <span class="st">"0.3*Las_H"</span>,</span>
<span>              <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>          , <span class="fl">0</span>          ,</span>
<span>              <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">0</span>          , <span class="fl">0</span></span>
<span>              <span class="op">)</span>, nrow <span class="op">=</span> <span class="fl">7</span>, ncol <span class="op">=</span> <span class="fl">7</span>, byrow<span class="op">=</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 列名と行名をつける</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dims</span></span></code></pre></div>
<p>最後のステップは、<span class="math inline">\(\boldsymbol{A}\)</span> 行列を <code>as.mxMatrix</code> 関数に入れて、ステージ2モデルで使用できるようにすることである。</p>
<div class="sourceCode" id="cb370"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/as.mxMatrix.html">as.mxMatrix</a></span><span class="op">(</span><span class="va">A</span><span class="op">)</span></span></code></pre></div>
<p><br></p>
<p><span class="math inline">\(\boldsymbol{S}\)</span> <strong>行列</strong></p>
<p><span class="math inline">\(\boldsymbol{S}\)</span> 行列では、推定したい分散を指定する。この例では、これらはすべての観測変数の分散と、2つの潜在要因の間の相関である。まず、潜在要因の自分自身との相関を1に設定した。さらに、観測された変数の分散は 0.2、相関は 0.3 という開始値を使用する。これらはすべてこのコードで指定することができる。</p>
<div class="sourceCode" id="cb371"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 分散を表す対角行列を作る</span></span>
<span><span class="va">Vars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/Diag.html">Diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"0.2*var_Q"</span>, <span class="st">"0.2*var_L"</span>, </span>
<span>               <span class="st">"0.2*var_E"</span>, <span class="st">"0.2*var_D"</span>, <span class="st">"0.2*var_H"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 潜在変数に対する行列を作成する</span></span>
<span><span class="va">Cors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"0.3*cor_InsLas"</span>,</span>
<span>                 <span class="st">"0.3*cor_InsLas"</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>               nrow<span class="op">=</span><span class="fl">2</span>, ncol<span class="op">=</span><span class="fl">2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 結合する</span></span>
<span><span class="va">S</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/bdiagMat.html">bdiagMat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">Vars</span>, <span class="va">Cors</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># 列名と行名をつける</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">S</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">S</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dims</span></span></code></pre></div>
<p>そして、再び、<code>as.mxMatrix</code> を用いて行列に変換する。</p>
<div class="sourceCode" id="cb372"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">S</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/as.mxMatrix.html">as.mxMatrix</a></span><span class="op">(</span><span class="va">S</span><span class="op">)</span></span></code></pre></div>
<p><br></p>
<p><span class="math inline">\(\boldsymbol{F}\)</span> <strong>行列</strong></p>
<p>最後に、<span class="math inline">\(\boldsymbol{F}\)</span> 行列を指定するのは簡単である。観測された変数の対角要素には 1 を記入し、それ以外は 0 を使用する。さらに、行列の少なくとも 1 つの要素が 0 でない行だけを選択する (つまり、最後の 2 行は 0 しか含まれていないので削除する)。</p>
<div class="sourceCode" id="cb373"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># 対角行列を作成</span></span>
<span><span class="va">F1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/Diag.html">Diag</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># ヌルでない行だけを選択</span></span>
<span><span class="va">F1</span> <span class="op">&lt;-</span> <span class="va">F1</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span>,<span class="op">]</span></span>
<span></span>
<span><span class="co"># 行ラベルと列ラベルの指定</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">F1</span><span class="op">)</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dims</span><span class="op">[</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/dimnames.html">dimnames</a></span><span class="op">(</span><span class="va">F1</span><span class="op">)</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">dims</span></span>
<span></span>
<span><span class="va">F1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/as.mxMatrix.html">as.mxMatrix</a></span><span class="op">(</span><span class="va">F1</span><span class="op">)</span></span></code></pre></div>
<p><br></p>
</div>
</div>
<div id="モデル適合" class="section level3" number="11.3.3">
<h3>
<span class="header-section-number">11.3.3</span> モデル適合<a class="anchor" aria-label="anchor" href="#%E3%83%A2%E3%83%87%E3%83%AB%E9%81%A9%E5%90%88"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>さて、いよいよ提案したモデルをプールされたデータに適合させる。これを行うには、 <code>tsem2</code> 関数を使用する。ステージ1のモデル <code>cfa1</code>、3つ行列、そして <code>diag.constraints=FALSE</code> を指定するだけである (mediation モデルを適用しているわけではないため)。結果として得られるオブジェクトを <code>cfa2</code> として保存し、<code>summary</code> を用いてアクセスする。</p>
<div class="sourceCode" id="cb374"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cfa2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/wls.html">tssem2</a></span><span class="op">(</span><span class="va">cfa1</span>, </span>
<span>               Amatrix <span class="op">=</span> <span class="va">A</span>, </span>
<span>               Smatrix <span class="op">=</span> <span class="va">S</span>, </span>
<span>               Fmatrix <span class="op">=</span> <span class="va">F1</span>, </span>
<span>               diag.constraints <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html">summary</a></span><span class="op">(</span><span class="va">cfa2</span><span class="op">)</span></span></code></pre></div>
<pre><code>## 
## Call:
## wls(Cov = pooledS, aCov = aCov, n = tssem1.obj$total.n, RAM = RAM, 
##     Amatrix = Amatrix, Smatrix = Smatrix, Fmatrix = Fmatrix, 
##     diag.constraints = diag.constraints, cor.analysis = cor.analysis, 
##     intervals.type = intervals.type, mx.algebras = mx.algebras, 
##     mxModel.Args = mxModel.Args, subset.variables = subset.variables, 
##     model.name = model.name, suppressWarnings = suppressWarnings, 
##     silent = silent, run = run)
## 
## 95% confidence intervals: z statistic approximation
## Coefficients:
##            Estimate Std.Error   lbound   ubound z value              Pr(&gt;|z|)
## Las_D      0.688251  0.081845 0.527838 0.848665  8.4092 &lt; 0.00000000000000022
## Ins_E      0.789438  0.060605 0.670654 0.908221 13.0260 &lt; 0.00000000000000022
## Las_H      0.741372  0.088425 0.568063 0.914681  8.3842 &lt; 0.00000000000000022
## Ins_L      0.658587  0.053650 0.553435 0.763739 12.2756 &lt; 0.00000000000000022
## Ins_Q      0.613591  0.051384 0.512879 0.714303 11.9412 &lt; 0.00000000000000022
## cor_InsLas 0.330274  0.045607 0.240886 0.419662  7.2418    0.0000000000004428
##               
## Las_D      ***
## Ins_E      ***
## Las_H      ***
## Ins_L      ***
## Ins_Q      ***
## cor_InsLas ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Goodness-of-fit indices:
##                                                Value
## Sample size                                3272.0000
## Chi-square of target model                    5.2640
## DF of target model                            4.0000
## p value of target model                       0.2613
## Number of constraints imposed on "Smatrix"    0.0000
## DF manually adjusted                          0.0000
## Chi-square of independence model            809.5366
## DF of independence model                     10.0000
## RMSEA                                         0.0098
## RMSEA lower 95% CI                            0.0000
## RMSEA upper 95% CI                            0.0297
## SRMR                                          0.0413
## TLI                                           0.9960
## CFI                                           0.9984
## AIC                                          -2.7360
## BIC                                         -27.1086
## OpenMx status1: 0 ("0" or "1": The optimization is considered fine.
## Other values indicate problems.)</code></pre>
<pre><code>## [...]
## Coefficients:
##            Estimate Std.Error lbound ubound z value Pr(&gt;|z|)    
## Las_D         0.688     0.081  0.527  0.848   8.409  &lt; 0.001 ***
## Ins_E         0.789     0.060  0.670  0.908  13.026  &lt; 0.001 ***
## Las_H         0.741     0.088  0.568  0.914   8.384  &lt; 0.001 ***
## Ins_L         0.658     0.053  0.553  0.763  12.275  &lt; 0.001 ***
## Ins_Q         0.613     0.051  0.512  0.714  11.941  &lt; 0.001 ***
## cor_InsLas    0.330     0.045  0.240  0.419   7.241  &lt; 0.001 ***
## ---
## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
## 
## Goodness-of-fit indices:
##                                                Value
## Sample size                                3272.0000
## Chi-square of target model                    5.2640
## DF of target model                            4.0000
## p value of target model                       0.2613
## [...]
## RMSEA                                         0.0098
## RMSEA lower 95% CI                            0.0000
## RMSEA upper 95% CI                            0.0297
## [...]
## OpenMx status1: 0 ("0" or "1": The optimization is considered fine.
## Other values indicate problems.)</code></pre>
<p><code>OpenMxの状態</code> が <code>0</code> であり、最適化がうまくいったことがわかる。出力では、Lassitude <span class="math inline">\(\rightarrow\)</span> Daytime Dysfunction (<code>Las_D</code>) の 0.69 のように、2つの潜在因子と観察された症状の間のパスの推定値が提供される。私たちはまた、モデルによると、2つの潜在的な要因の間に有意な相関があることがわかる。<span class="math inline">\(r_{\text{Ins,Las}}\)</span> = 0.33.</p>
<p>しかし、最も重要なことは、想定したモデルがどの程度データに適合しているかをチェックすることである。これは <code>Goodness-of-fit indices</code> を見ることによって達成可能である。適合度検定は、<span class="math inline">\(\chi^2_4=\)</span> 5.26、<span class="math inline">\(p=\)</span> 0.26 で、<strong>有意でない</strong>ことがわかる。他の統計検定とは異なり、このアウトカムは、私たちのモデルがデータに<strong>よく</strong>適合するという帰無仮説を受け入れることを意味するので、望ましい結果である。</p>
<p></p>
<p>さらに、<strong>近似値の二乗平均平方根誤差</strong> (Root Mean Square Error of Approximation, RMSEA) の値は 0.0098 であることがわかる。経験則では、RSMEA の値が 0.05 以下であれば、モデルはデータによく適合していると考えることができ、値が小さいほど適合度が高いことを示している <span class="citation">(<a href="references.html#ref-rmsea">Browne and Cudeck 1993</a>)</span>。したがって、この適合度指数も、モデルが私たちのデータによく適合していることを示している。</p>
<div class="boximportant">
<p>
<strong>代替モデル</strong>
</p>
<p>
SEM
研究によくある問題は、研究者が自分の提唱するモデルにのみ注目し、それがデータにうまく適合するかどうかに注目しがちなことである。もし、想定したモデルがデータに近い適合を示すことがわかれば、多くの研究者は、データが自分の理論を証明したと直接結論づけることが多い。
</p>
<p>
しかし、同じデータに対して複数のモデルがうまく適合する可能性があるため、これは問題である。したがって、代替モデルの仮説や構造も確認する必要がある。もし、代替モデルもデータにうまくフィットすれば、我々の提案した構造が本当に「正しい」ものなのかどうかがわからなくなる。
</p>
</div>
<p><br></p>
</div>
<div id="パス図-1" class="section level3" number="11.3.4">
<h3>
<span class="header-section-number">11.3.4</span> パス図<a class="anchor" aria-label="anchor" href="#%E3%83%91%E3%82%B9%E5%9B%B3-1"><i class="fas fa-link"></i></a>
</h3>
<hr>
<p>
</p>
<p>モデルの適合後、<strong>{metaSEM}</strong> はそれをグラフィカルに可視化することを非常に簡単にしてくれる。パス図を描くためには、まず、<strong>{semPlot}</strong> パッケージ <span class="citation">(<a href="references.html#ref-semplot">Epskamp 2019</a>)</span> をインストールし、ロードする必要がある。</p>
<div class="sourceCode" id="cb377"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/SachaEpskamp/semPlot">semPlot</a></span><span class="op">)</span></span></code></pre></div>
<p>モデルをプロットするために、<strong>{semPlot}</strong> が使用できる形式に変換する必要があるので、<code>meta2semPlot</code> 関数を使用して行っておこう。</p>
<div class="sourceCode" id="cb378"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cfa.plot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/metaSEM/man/meta2semPlot.html">meta2semPlot</a></span><span class="op">(</span><span class="va">cfa2</span><span class="op">)</span></span></code></pre></div>
<p>そして、グラフを生成するために、<strong>{semPlot}</strong> の <code>semPaths</code> 関数を使ってみよう。この関数は多くのパラメータを持っており、コンソールに <code><a href="https://rdrr.io/pkg/semPlot/man/semPaths.html">?semPaths</a></code> と入力し、Enter キーを押すことでアクセスすることが可能である。以下がコードと結果のプロットである。</p>
<div class="sourceCode" id="cb379"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># macOS 用文字化け対策</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html">par</a></span><span class="op">(</span>family<span class="op">=</span> <span class="st">"HiraKakuProN-W3"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># プロットラベルを作成 (左から右、下から上) </span></span>
<span><span class="va">labels</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"睡眠\nの質"</span>,</span>
<span>            <span class="st">"睡眠\n潜時"</span>,</span>
<span>            <span class="st">"睡眠\n効率"</span>,</span>
<span>            <span class="st">"日中機\n能障害"</span>,</span>
<span>            <span class="st">"過眠症"</span>,<span class="st">"不眠"</span>, </span>
<span>            <span class="st">"倦怠感"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># プロット</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/semPlot/man/semPaths.html">semPaths</a></span><span class="op">(</span><span class="va">cfa.plot</span>, </span>
<span>         whatLabels <span class="op">=</span> <span class="st">"est"</span>, </span>
<span>         edge.color <span class="op">=</span> <span class="st">"black"</span>, </span>
<span>         nodeLabels <span class="op">=</span> <span class="va">labels</span>,</span>
<span>         sizeMan <span class="op">=</span> <span class="fl">10</span>, </span>
<span>         sizeLat <span class="op">=</span> <span class="fl">10</span>, </span>
<span>         edge.label.cex <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<div class="inline-figure"><img src="Doing_Meta_Analysis_in_R_files/figure-html/unnamed-chunk-341-1.png" width="60%" style="display: block; margin: auto;"></div>
<div class="boxinfo">
<p>
<strong>更なる学習</strong>
</p>
<p>
この章で取り上げたことは、メタアナリシス SEM
の初歩的な入門として捉えていただきたい。より詳細なメタアナリシス SEM
の議論は、Mike Cheung の決定的な本である <strong>Meta-Analysis: A
Structural Equation Modeling Approach</strong> <span class="citation"><span class="citation">(<a href="references.html#ref-cheung2015meta">2015a</a>)</span></span>
に記載されている。この本は、ここでカバーしていない他のさまざまな種類のメタ分析構造方程式モデルについても記述しており、
<em>R</em> を使用してどのように実装できるかを説明されている。
</p>
<p>
短めの (そして、オープンにアクセスできる)
リソースを探すのであれば、<strong>{metaSEM}</strong> パッケージの
vignette をお読みいただきたい。この vignette
には、メタアナリシスSEMの理論について簡単に説明し、 <em>R</em>
を使ったいくつかの図解を掲載している。<strong>{metaSEM}</strong>
をロードした後、コンソールで <code>vignette(“metaSEM”)</code>
を実行することにより、インターネットからヴィネットをダウンロードすることができる。
</p>
</div>
<p><span class="math display">\[\tag*{$\blacksquare$}\]</span></p>
<p><br></p>
</div>
</div>
<div id="演習問題-10" class="section level2" number="11.4">
<h2>
<span class="header-section-number">11.4</span> 演習問題<a class="anchor" aria-label="anchor" href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C-10"><i class="fas fa-link"></i></a>
</h2>
<div class="boxquestion">
<p>
<strong>知識を試そう！</strong>
</p>
<ol style="list-style-type: decimal">
<li>
構造方程式モデリングとは何か、何のために使うのか。
</li>
</ol>
<ol start="2" style="list-style-type: decimal">
<li>
SEM の表現方法として、どのようなものがあるか？
</li>
</ol>
<ol start="3" style="list-style-type: decimal">
<li>
ランダム効果メタ分析を SEM の観点から説明しなさい。
</li>
</ol>
<ol start="4" style="list-style-type: decimal">
<li>
多変量メタ分析とは何か、どのような場合に有用か。
</li>
</ol>
<ol start="5" style="list-style-type: decimal">
<li>
提案したメタ分析 SEM
がデータによく適合することがわかったとき、このモデルが自動的に「正しい」モデルであることを意味するのだろうか。
</li>
</ol>
<p>
<strong>問題の解答は、本書の巻末 <a href="https://bookdown.org/baba_yoshihiko/Doing_Meta_Analysis_in_R/qanda.html#qanda11">Appendix
A</a> にある。</strong>
</p>
</div>
<p><br></p>
</div>
<div id="要約-7" class="section level2" number="11.5">
<h2>
<span class="header-section-number">11.5</span> 要約<a class="anchor" aria-label="anchor" href="#%E8%A6%81%E7%B4%84-7"><i class="fas fa-link"></i></a>
</h2>
<ul>
<li><p>構造方程式モデリング (SEM) は、観測される (＝顕在) 変数と観測されない (＝潜在) 変数の間の<strong>複雑な関係</strong>を検証するために使用できる統計手法である。</p></li>
<li><p>メタ分析はマルチレベルモデルに基づいているため、SEM の観点からも定式化することが可能である。これは、ランダム効果メタ分析を構造方程式モデルとして「複製」するために使用することが可能である。しかし、より重要なことは、観測された効果量間のより複雑な関係をモデル化したメタ分析を行うことができることである。</p></li>
<li><p>メタ分析 SEM は、例えば、<strong>多変量メタ分析</strong>を行うために適用することができる。多変量メタ分析では、2つ以上のアウトカムを、両アウトカム間の相関を考慮しながら、共同で推定する。</p></li>
<li><p>メタ分析的 SEM のもう一つの応用は、<strong>確証的因子分析</strong>である。含まれるすべての研究にわたって提案された因子モデルの適合性をテストするために、2段階の手順を使用しなければならない。第一段階では、個々の研究の相関行列がプールされる。そして、このプールされた相関行列は、想定された SEM を適合させるために使用される。</p></li>
</ul>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="multilevel-ma.html"><span class="header-section-number">10</span> 「マルチレベル」メタ分析</a></div>
<div class="next"><a href="netwma.html"><span class="header-section-number">12</span> ネットワークメタ分析</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#sem"><span class="header-section-number">11</span> 構造方程式モデリングメタ分析</a></li>
<li>
<a class="nav-link" href="#what-is-meta-sem"><span class="header-section-number">11.1</span> メタ分析構造方程式モデリングとは？</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E3%83%A2%E3%83%87%E3%83%AB%E4%BB%95%E6%A7%98"><span class="header-section-number">11.1.1</span> モデル仕様</a></li>
<li><a class="nav-link" href="#sem-%E3%81%AE%E8%A6%B3%E7%82%B9%E3%81%8B%E3%82%89%E3%81%AE%E3%83%A1%E3%82%BF%E5%88%86%E6%9E%90"><span class="header-section-number">11.1.2</span> SEM の観点からのメタ分析</a></li>
<li><a class="nav-link" href="#%E6%AE%B5%E9%9A%8E%E3%83%A1%E3%82%BF%E5%88%86%E6%9E%90-sem-%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81"><span class="header-section-number">11.1.3</span> ２段階メタ分析 SEM アプローチ</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#multivariate-ma"><span class="header-section-number">11.2</span> 多変量メタ分析</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E3%83%A2%E3%83%87%E3%83%AB%E3%81%AE%E6%8C%87%E5%AE%9A"><span class="header-section-number">11.2.1</span> モデルの指定</a></li>
<li><a class="nav-link" href="#%E7%B5%90%E6%9E%9C%E3%81%AE%E8%A9%95%E4%BE%A1"><span class="header-section-number">11.2.2</span> 結果の評価</a></li>
<li><a class="nav-link" href="#%E7%B5%90%E6%9E%9C%E3%81%AE%E5%8F%AF%E8%A6%96%E5%8C%96"><span class="header-section-number">11.2.3</span> 結果の可視化</a></li>
</ul>
</li>
<li>
<a class="nav-link" href="#cfa"><span class="header-section-number">11.3</span> 確証的因子分析</a><ul class="nav navbar-nav">
<li><a class="nav-link" href="#%E3%83%87%E3%83%BC%E3%82%BF%E6%BA%96%E5%82%99"><span class="header-section-number">11.3.1</span> データ準備</a></li>
<li><a class="nav-link" href="#%E3%83%A2%E3%83%87%E3%83%AB%E4%BB%95%E6%A7%98-1"><span class="header-section-number">11.3.2</span> モデル仕様</a></li>
<li><a class="nav-link" href="#%E3%83%A2%E3%83%87%E3%83%AB%E9%81%A9%E5%90%88"><span class="header-section-number">11.3.3</span> モデル適合</a></li>
<li><a class="nav-link" href="#%E3%83%91%E3%82%B9%E5%9B%B3-1"><span class="header-section-number">11.3.4</span> パス図</a></li>
</ul>
</li>
<li><a class="nav-link" href="#%E6%BC%94%E7%BF%92%E5%95%8F%E9%A1%8C-10"><span class="header-section-number">11.4</span> 演習問題</a></li>
<li><a class="nav-link" href="#%E8%A6%81%E7%B4%84-7"><span class="header-section-number">11.5</span> 要約</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
          
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Doing Meta-Analysis in R</strong>: A Hands-on Guide" was written by Mathias Harrer, Pim Cuijpers, Toshi A. Furukawa, David D. Ebert. </p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
